/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len(),
        );
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len(),
        );
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const FLT_INTERNAL_OPERATION_COUNT: u32 = 22;
pub const FLT_ALLOCATE_CALLBACK_DATA_PREALLOCATE_ALL_MEMORY: u32 = 1;
pub const FLT_VOLUME_CONTEXT: u32 = 1;
pub const FLT_INSTANCE_CONTEXT: u32 = 2;
pub const FLT_FILE_CONTEXT: u32 = 4;
pub const FLT_STREAM_CONTEXT: u32 = 8;
pub const FLT_STREAMHANDLE_CONTEXT: u32 = 16;
pub const FLT_TRANSACTION_CONTEXT: u32 = 32;
pub const FLT_SECTION_CONTEXT: u32 = 64;
pub const FLT_CONTEXT_END: u32 = 65535;
pub const FLT_ALL_CONTEXTS: u32 = 127;
pub const FLT_REGISTRATION_VERSION_0200: u32 = 512;
pub const FLT_REGISTRATION_VERSION_0201: u32 = 513;
pub const FLT_REGISTRATION_VERSION_0202: u32 = 514;
pub const FLT_REGISTRATION_VERSION_0203: u32 = 515;
pub const FLT_REGISTRATION_VERSION: u32 = 515;
pub const FLT_VALID_FILE_NAME_FORMATS: u32 = 255;
pub const FLT_FILE_NAME_NORMALIZED: u32 = 1;
pub const FLT_FILE_NAME_OPENED: u32 = 2;
pub const FLT_FILE_NAME_SHORT: u32 = 3;
pub const FLT_VALID_FILE_NAME_QUERY_METHODS: u32 = 65280;
pub const FLT_FILE_NAME_QUERY_DEFAULT: u32 = 256;
pub const FLT_FILE_NAME_QUERY_CACHE_ONLY: u32 = 512;
pub const FLT_FILE_NAME_QUERY_FILESYSTEM_ONLY: u32 = 768;
pub const FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP: u32 = 1024;
pub const FLT_VALID_FILE_NAME_FLAGS: u32 = 4278190080;
pub const FLT_FILE_NAME_REQUEST_FROM_CURRENT_PROVIDER: u32 = 16777216;
pub const FLT_FILE_NAME_DO_NOT_CACHE: u32 = 33554432;
pub const FLT_FILE_NAME_ALLOW_QUERY_ON_REPARSE: u32 = 67108864;
pub const FLT_MAX_DEVICE_REPARSE_ATTEMPTS: u32 = 64;
pub const FLT_FLUSH_TYPE_FLUSH_AND_PURGE: u32 = 1;
pub const FLT_FLUSH_TYPE_FILE_DATA_ONLY: u32 = 2;
pub const FLT_FLUSH_TYPE_NO_SYNC: u32 = 4;
pub const FLT_FLUSH_TYPE_DATA_SYNC_ONLY: u32 = 8;
pub const FLT_PORT_CONNECT: u32 = 1;
pub const FLT_PORT_ALL_ACCESS: u32 = 2031617;
pub const FLT_PUSH_LOCK_ENABLE_AUTO_BOOST: u32 = 1;
pub const FLT_PUSH_LOCK_DISABLE_AUTO_BOOST: u32 = 2;
pub const FLT_PUSH_LOCK_VALID_FLAGS: u32 = 3;
pub const FLT_MAX_TRANSACTION_NOTIFICATIONS: u32 = 1073741839;
pub type wchar_t = ::core::ffi::c_ushort;
pub type LONG_PTR = ::core::ffi::c_longlong;
pub type ULONG_PTR = ::core::ffi::c_ulonglong;
pub type PULONG_PTR = *mut ::core::ffi::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type LONG64 = ::core::ffi::c_longlong;
pub type KAFFINITY = ULONG_PTR;
pub type PVOID = *mut ::core::ffi::c_void;
pub type CHAR = ::core::ffi::c_char;
pub type SHORT = ::core::ffi::c_short;
pub type LONG = ::core::ffi::c_long;
pub type WCHAR = wchar_t;
pub type PWCH = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type PCHAR = *mut CHAR;
pub type PCSTR = *const CHAR;
pub type UCHAR = ::core::ffi::c_uchar;
pub type USHORT = ::core::ffi::c_ushort;
pub type ULONG = ::core::ffi::c_ulong;
pub type PULONG = *mut ULONG;
pub type HANDLE = *mut ::core::ffi::c_void;
pub type PHANDLE = *mut HANDLE;
pub type CCHAR = ::core::ffi::c_char;
pub type CSHORT = ::core::ffi::c_short;
pub type LCID = ULONG;
pub type NTSTATUS = LONG;
pub type LONGLONG = ::core::ffi::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart),
        ),
    );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER)),
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_LARGE_INTEGER), "::", stringify!(u)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(QuadPart),
        ),
    );
}
impl Default for _LARGE_INTEGER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LUID {
    pub LowPart: ULONG,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LUID() {
    const UNINIT: ::core::mem::MaybeUninit<_LUID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LUID>(),
        8usize,
        concat!("Size of: ", stringify!(_LUID)),
    );
    assert_eq!(
        ::core::mem::align_of::<_LUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_LUID)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_LUID), "::", stringify!(LowPart)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_LUID), "::", stringify!(HighPart)),
    );
}
pub type LUID = _LUID;
pub type PHYSICAL_ADDRESS = LARGE_INTEGER;
pub mod _WAIT_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const WaitAll: Type = 0;
    pub const WaitAny: Type = 1;
    pub const WaitNotification: Type = 2;
    pub const WaitDequeue: Type = 3;
    pub const WaitDpc: Type = 4;
}
pub use self::_WAIT_TYPE::Type as WAIT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PCHAR,
}
#[test]
fn bindgen_test_layout__STRING() {
    const UNINIT: ::core::mem::MaybeUninit<_STRING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_STRING>(),
        16usize,
        concat!("Size of: ", stringify!(_STRING)),
    );
    assert_eq!(
        ::core::mem::align_of::<_STRING>(),
        8usize,
        concat!("Alignment of ", stringify!(_STRING)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_STRING), "::", stringify!(Length)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(MaximumLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_STRING), "::", stringify!(Buffer)),
    );
}
impl Default for _STRING {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type STRING = _STRING;
pub type PSTRING = *mut STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PWCH,
}
#[test]
fn bindgen_test_layout__UNICODE_STRING() {
    const UNINIT: ::core::mem::MaybeUninit<_UNICODE_STRING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_UNICODE_STRING>(),
        16usize,
        concat!("Size of: ", stringify!(_UNICODE_STRING)),
    );
    assert_eq!(
        ::core::mem::align_of::<_UNICODE_STRING>(),
        8usize,
        concat!("Alignment of ", stringify!(_UNICODE_STRING)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(MaximumLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Buffer),
        ),
    );
}
impl Default for _UNICODE_STRING {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type UNICODE_STRING = _UNICODE_STRING;
pub type PUNICODE_STRING = *mut UNICODE_STRING;
pub type PCUNICODE_STRING = *const UNICODE_STRING;
pub type BOOLEAN = UCHAR;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_LIST_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LIST_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_LIST_ENTRY)),
    );
    assert_eq!(
        ::core::mem::align_of::<_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_LIST_ENTRY)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flink) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_LIST_ENTRY), "::", stringify!(Flink)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Blink) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_LIST_ENTRY), "::", stringify!(Blink)),
    );
}
impl Default for _LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LIST_ENTRY = _LIST_ENTRY;
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_SINGLE_LIST_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SINGLE_LIST_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_SINGLE_LIST_ENTRY)),
    );
    assert_eq!(
        ::core::mem::align_of::<_SINGLE_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_SINGLE_LIST_ENTRY)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SINGLE_LIST_ENTRY),
            "::",
            stringify!(Next),
        ),
    );
}
impl Default for _SINGLE_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES {
    pub Length: ULONG,
    pub RootDirectory: HANDLE,
    pub ObjectName: PUNICODE_STRING,
    pub Attributes: ULONG,
    pub SecurityDescriptor: PVOID,
    pub SecurityQualityOfService: PVOID,
}
#[test]
fn bindgen_test_layout__OBJECT_ATTRIBUTES() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_ATTRIBUTES> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_ATTRIBUTES>(),
        48usize,
        concat!("Size of: ", stringify!(_OBJECT_ATTRIBUTES)),
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_ATTRIBUTES>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_ATTRIBUTES)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(RootDirectory),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(ObjectName),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(Attributes),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(SecurityDescriptor),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityQualityOfService) as usize
                - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(SecurityQualityOfService),
        ),
    );
}
impl Default for _OBJECT_ATTRIBUTES {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES;
pub type POBJECT_ATTRIBUTES = *mut OBJECT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GUID {
    pub Data1: ::core::ffi::c_ulong,
    pub Data2: ::core::ffi::c_ushort,
    pub Data3: ::core::ffi::c_ushort,
    pub Data4: [::core::ffi::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
    const UNINIT: ::core::mem::MaybeUninit<_GUID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID)),
    );
    assert_eq!(
        ::core::mem::align_of::<_GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_GUID)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Data1) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_GUID), "::", stringify!(Data1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Data2) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_GUID), "::", stringify!(Data2)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Data3) as usize - ptr as usize },
        6usize,
        concat!("Offset of field: ", stringify!(_GUID), "::", stringify!(Data3)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Data4) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GUID), "::", stringify!(Data4)),
    );
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type KIRQL = UCHAR;
pub type PKIRQL = *mut KIRQL;
pub type PACCESS_STATE = *mut _ACCESS_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPROCESS {
    _unused: [u8; 0],
}
pub type PEPROCESS = *mut _KPROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTHREAD {
    _unused: [u8; 0],
}
pub type PETHREAD = *mut _KTHREAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_TIMER {
    _unused: [u8; 0],
}
pub type PIO_TIMER = *mut _IO_TIMER;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
pub type PVPB = *mut _VPB;
pub type PFILE_GET_QUOTA_INFORMATION = *mut _FILE_GET_QUOTA_INFORMATION;
pub type KSPIN_LOCK = ULONG_PTR;
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type ACCESS_MASK = ULONG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: ULONG,
}
#[test]
fn bindgen_test_layout__LUID_AND_ATTRIBUTES() {
    const UNINIT: ::core::mem::MaybeUninit<_LUID_AND_ATTRIBUTES> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LUID_AND_ATTRIBUTES>(),
        12usize,
        concat!("Size of: ", stringify!(_LUID_AND_ATTRIBUTES)),
    );
    assert_eq!(
        ::core::mem::align_of::<_LUID_AND_ATTRIBUTES>(),
        4usize,
        concat!("Alignment of ", stringify!(_LUID_AND_ATTRIBUTES)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Luid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID_AND_ATTRIBUTES),
            "::",
            stringify!(Luid),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID_AND_ATTRIBUTES),
            "::",
            stringify!(Attributes),
        ),
    );
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__PRIVILEGE_SET() {
    const UNINIT: ::core::mem::MaybeUninit<_PRIVILEGE_SET> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PRIVILEGE_SET>(),
        20usize,
        concat!("Size of: ", stringify!(_PRIVILEGE_SET)),
    );
    assert_eq!(
        ::core::mem::align_of::<_PRIVILEGE_SET>(),
        4usize,
        concat!("Alignment of ", stringify!(_PRIVILEGE_SET)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrivilegeCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(PrivilegeCount),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Control) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(Control),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Privilege) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(Privilege),
        ),
    );
}
pub type PRIVILEGE_SET = _PRIVILEGE_SET;
pub mod _SECURITY_IMPERSONATION_LEVEL {
    pub type Type = ::core::ffi::c_int;
    pub const SecurityAnonymous: Type = 0;
    pub const SecurityIdentification: Type = 1;
    pub const SecurityImpersonation: Type = 2;
    pub const SecurityDelegation: Type = 3;
}
pub use self::_SECURITY_IMPERSONATION_LEVEL::Type as SECURITY_IMPERSONATION_LEVEL;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    pub Length: ULONG,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
    pub EffectiveOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SECURITY_QUALITY_OF_SERVICE() {
    const UNINIT: ::core::mem::MaybeUninit<_SECURITY_QUALITY_OF_SERVICE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SECURITY_QUALITY_OF_SERVICE>(),
        12usize,
        concat!("Size of: ", stringify!(_SECURITY_QUALITY_OF_SERVICE)),
    );
    assert_eq!(
        ::core::mem::align_of::<_SECURITY_QUALITY_OF_SERVICE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SECURITY_QUALITY_OF_SERVICE)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ImpersonationLevel) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(ImpersonationLevel),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ContextTrackingMode) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(ContextTrackingMode),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EffectiveOnly) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(EffectiveOnly),
        ),
    );
}
impl Default for _SECURITY_QUALITY_OF_SERVICE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SECURITY_INFORMATION = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_STATUS_BLOCK__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Status),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Pointer),
        ),
    );
}
impl Default for _IO_STATUS_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_STATUS_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STATUS_BLOCK>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STATUS_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Information) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK),
            "::",
            stringify!(Information),
        ),
    );
}
impl Default for _IO_STATUS_BLOCK {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
pub type PIO_APC_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Reserved: ULONG,
    ),
>;
pub mod _FILE_INFORMATION_CLASS {
    pub type Type = ::core::ffi::c_int;
    pub const FileDirectoryInformation: Type = 1;
    pub const FileFullDirectoryInformation: Type = 2;
    pub const FileBothDirectoryInformation: Type = 3;
    pub const FileBasicInformation: Type = 4;
    pub const FileStandardInformation: Type = 5;
    pub const FileInternalInformation: Type = 6;
    pub const FileEaInformation: Type = 7;
    pub const FileAccessInformation: Type = 8;
    pub const FileNameInformation: Type = 9;
    pub const FileRenameInformation: Type = 10;
    pub const FileLinkInformation: Type = 11;
    pub const FileNamesInformation: Type = 12;
    pub const FileDispositionInformation: Type = 13;
    pub const FilePositionInformation: Type = 14;
    pub const FileFullEaInformation: Type = 15;
    pub const FileModeInformation: Type = 16;
    pub const FileAlignmentInformation: Type = 17;
    pub const FileAllInformation: Type = 18;
    pub const FileAllocationInformation: Type = 19;
    pub const FileEndOfFileInformation: Type = 20;
    pub const FileAlternateNameInformation: Type = 21;
    pub const FileStreamInformation: Type = 22;
    pub const FilePipeInformation: Type = 23;
    pub const FilePipeLocalInformation: Type = 24;
    pub const FilePipeRemoteInformation: Type = 25;
    pub const FileMailslotQueryInformation: Type = 26;
    pub const FileMailslotSetInformation: Type = 27;
    pub const FileCompressionInformation: Type = 28;
    pub const FileObjectIdInformation: Type = 29;
    pub const FileCompletionInformation: Type = 30;
    pub const FileMoveClusterInformation: Type = 31;
    pub const FileQuotaInformation: Type = 32;
    pub const FileReparsePointInformation: Type = 33;
    pub const FileNetworkOpenInformation: Type = 34;
    pub const FileAttributeTagInformation: Type = 35;
    pub const FileTrackingInformation: Type = 36;
    pub const FileIdBothDirectoryInformation: Type = 37;
    pub const FileIdFullDirectoryInformation: Type = 38;
    pub const FileValidDataLengthInformation: Type = 39;
    pub const FileShortNameInformation: Type = 40;
    pub const FileIoCompletionNotificationInformation: Type = 41;
    pub const FileIoStatusBlockRangeInformation: Type = 42;
    pub const FileIoPriorityHintInformation: Type = 43;
    pub const FileSfioReserveInformation: Type = 44;
    pub const FileSfioVolumeInformation: Type = 45;
    pub const FileHardLinkInformation: Type = 46;
    pub const FileProcessIdsUsingFileInformation: Type = 47;
    pub const FileNormalizedNameInformation: Type = 48;
    pub const FileNetworkPhysicalNameInformation: Type = 49;
    pub const FileIdGlobalTxDirectoryInformation: Type = 50;
    pub const FileIsRemoteDeviceInformation: Type = 51;
    pub const FileUnusedInformation: Type = 52;
    pub const FileNumaNodeInformation: Type = 53;
    pub const FileStandardLinkInformation: Type = 54;
    pub const FileRemoteProtocolInformation: Type = 55;
    pub const FileRenameInformationBypassAccessCheck: Type = 56;
    pub const FileLinkInformationBypassAccessCheck: Type = 57;
    pub const FileVolumeNameInformation: Type = 58;
    pub const FileIdInformation: Type = 59;
    pub const FileIdExtdDirectoryInformation: Type = 60;
    pub const FileReplaceCompletionInformation: Type = 61;
    pub const FileHardLinkFullIdInformation: Type = 62;
    pub const FileIdExtdBothDirectoryInformation: Type = 63;
    pub const FileDispositionInformationEx: Type = 64;
    pub const FileRenameInformationEx: Type = 65;
    pub const FileRenameInformationExBypassAccessCheck: Type = 66;
    pub const FileDesiredStorageClassInformation: Type = 67;
    pub const FileStatInformation: Type = 68;
    pub const FileMemoryPartitionInformation: Type = 69;
    pub const FileStatLxInformation: Type = 70;
    pub const FileCaseSensitiveInformation: Type = 71;
    pub const FileLinkInformationEx: Type = 72;
    pub const FileLinkInformationExBypassAccessCheck: Type = 73;
    pub const FileStorageReserveIdInformation: Type = 74;
    pub const FileCaseSensitiveInformationForceAccessCheck: Type = 75;
    pub const FileKnownFolderInformation: Type = 76;
    pub const FileStatBasicInformation: Type = 77;
    pub const FileId64ExtdDirectoryInformation: Type = 78;
    pub const FileId64ExtdBothDirectoryInformation: Type = 79;
    pub const FileIdAllExtdDirectoryInformation: Type = 80;
    pub const FileIdAllExtdBothDirectoryInformation: Type = 81;
    pub const FileMaximumInformation: Type = 82;
}
pub use self::_FILE_INFORMATION_CLASS::Type as FILE_INFORMATION_CLASS;
pub mod _DIRECTORY_NOTIFY_INFORMATION_CLASS {
    pub type Type = ::core::ffi::c_int;
    pub const DirectoryNotifyInformation: Type = 1;
    pub const DirectoryNotifyExtendedInformation: Type = 2;
    pub const DirectoryNotifyFullInformation: Type = 3;
    pub const DirectoryNotifyMaximumInformation: Type = 4;
}
pub use self::_DIRECTORY_NOTIFY_INFORMATION_CLASS::Type as DIRECTORY_NOTIFY_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_BASIC_INFORMATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_BASIC_INFORMATION>(),
        40usize,
        concat!("Size of: ", stringify!(_FILE_BASIC_INFORMATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_BASIC_INFORMATION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(CreationTime),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastAccessTime),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastWriteTime),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(ChangeTime),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(FileAttributes),
        ),
    );
}
impl Default for _FILE_BASIC_INFORMATION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_STANDARD_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_STANDARD_INFORMATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_STANDARD_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_STANDARD_INFORMATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_STANDARD_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_STANDARD_INFORMATION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(AllocationSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(EndOfFile),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfLinks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(NumberOfLinks),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeletePending) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(DeletePending),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Directory) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(Directory),
        ),
    );
}
impl Default for _FILE_STANDARD_INFORMATION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_NETWORK_OPEN_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NETWORK_OPEN_INFORMATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_FILE_NETWORK_OPEN_INFORMATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_NETWORK_OPEN_INFORMATION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(CreationTime),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastAccessTime),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastWriteTime),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(ChangeTime),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(AllocationSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(EndOfFile),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(FileAttributes),
        ),
    );
}
impl Default for _FILE_NETWORK_OPEN_INFORMATION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
pub mod _IO_PRIORITY_HINT {
    pub type Type = ::core::ffi::c_int;
    pub const IoPriorityVeryLow: Type = 0;
    pub const IoPriorityLow: Type = 1;
    pub const IoPriorityNormal: Type = 2;
    pub const IoPriorityHigh: Type = 3;
    pub const IoPriorityCritical: Type = 4;
    pub const MaxIoPriorityTypes: Type = 5;
}
pub use self::_IO_PRIORITY_HINT::Type as IO_PRIORITY_HINT;
pub mod _FSINFOCLASS {
    pub type Type = ::core::ffi::c_int;
    pub const FileFsVolumeInformation: Type = 1;
    pub const FileFsLabelInformation: Type = 2;
    pub const FileFsSizeInformation: Type = 3;
    pub const FileFsDeviceInformation: Type = 4;
    pub const FileFsAttributeInformation: Type = 5;
    pub const FileFsControlInformation: Type = 6;
    pub const FileFsFullSizeInformation: Type = 7;
    pub const FileFsObjectIdInformation: Type = 8;
    pub const FileFsDriverPathInformation: Type = 9;
    pub const FileFsVolumeFlagsInformation: Type = 10;
    pub const FileFsSectorSizeInformation: Type = 11;
    pub const FileFsDataCopyInformation: Type = 12;
    pub const FileFsMetadataSizeInformation: Type = 13;
    pub const FileFsFullSizeInformationEx: Type = 14;
    pub const FileFsGuidInformation: Type = 15;
    pub const FileFsMaximumInformation: Type = 16;
}
pub use self::_FSINFOCLASS::Type as FS_INFORMATION_CLASS;
pub mod _INTERFACE_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const InterfaceTypeUndefined: Type = -1;
    pub const Internal: Type = 0;
    pub const Isa: Type = 1;
    pub const Eisa: Type = 2;
    pub const MicroChannel: Type = 3;
    pub const TurboChannel: Type = 4;
    pub const PCIBus: Type = 5;
    pub const VMEBus: Type = 6;
    pub const NuBus: Type = 7;
    pub const PCMCIABus: Type = 8;
    pub const CBus: Type = 9;
    pub const MPIBus: Type = 10;
    pub const MPSABus: Type = 11;
    pub const ProcessorInternal: Type = 12;
    pub const InternalPowerBus: Type = 13;
    pub const PNPISABus: Type = 14;
    pub const PNPBus: Type = 15;
    pub const Vmcs: Type = 16;
    pub const ACPIBus: Type = 17;
    pub const MaximumInterfaceType: Type = 18;
}
pub use self::_INTERFACE_TYPE::Type as INTERFACE_TYPE;
pub type PINTERFACE_REFERENCE = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID),
>;
pub type PINTERFACE_DEREFERENCE = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID),
>;
pub mod _SYSTEM_POWER_STATE {
    pub type Type = ::core::ffi::c_int;
    pub const PowerSystemUnspecified: Type = 0;
    pub const PowerSystemWorking: Type = 1;
    pub const PowerSystemSleeping1: Type = 2;
    pub const PowerSystemSleeping2: Type = 3;
    pub const PowerSystemSleeping3: Type = 4;
    pub const PowerSystemHibernate: Type = 5;
    pub const PowerSystemShutdown: Type = 6;
    pub const PowerSystemMaximum: Type = 7;
}
pub use self::_SYSTEM_POWER_STATE::Type as SYSTEM_POWER_STATE;
pub mod POWER_ACTION {
    pub type Type = ::core::ffi::c_int;
    pub const PowerActionNone: Type = 0;
    pub const PowerActionReserved: Type = 1;
    pub const PowerActionSleep: Type = 2;
    pub const PowerActionHibernate: Type = 3;
    pub const PowerActionShutdown: Type = 4;
    pub const PowerActionShutdownReset: Type = 5;
    pub const PowerActionShutdownOff: Type = 6;
    pub const PowerActionWarmEject: Type = 7;
    pub const PowerActionDisplayOff: Type = 8;
}
pub mod _DEVICE_POWER_STATE {
    pub type Type = ::core::ffi::c_int;
    pub const PowerDeviceUnspecified: Type = 0;
    pub const PowerDeviceD0: Type = 1;
    pub const PowerDeviceD1: Type = 2;
    pub const PowerDeviceD2: Type = 3;
    pub const PowerDeviceD3: Type = 4;
    pub const PowerDeviceMaximum: Type = 5;
}
pub use self::_DEVICE_POWER_STATE::Type as DEVICE_POWER_STATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _POWER_STATE {
    pub SystemState: SYSTEM_POWER_STATE,
    pub DeviceState: DEVICE_POWER_STATE,
}
#[test]
fn bindgen_test_layout__POWER_STATE() {
    const UNINIT: ::core::mem::MaybeUninit<_POWER_STATE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_POWER_STATE>(),
        4usize,
        concat!("Size of: ", stringify!(_POWER_STATE)),
    );
    assert_eq!(
        ::core::mem::align_of::<_POWER_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_STATE)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_STATE),
            "::",
            stringify!(SystemState),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_STATE),
            "::",
            stringify!(DeviceState),
        ),
    );
}
impl Default for _POWER_STATE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type POWER_STATE = _POWER_STATE;
pub mod _POWER_STATE_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const SystemPowerState: Type = 0;
    pub const DevicePowerState: Type = 1;
}
pub use self::_POWER_STATE_TYPE::Type as POWER_STATE_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    pub __bindgen_anon_1: _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
    pub ContextAsUlong: ULONG,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<
            _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1),
        ),
    );
}
impl _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn TargetSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_TargetSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn EffectiveSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_EffectiveSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CurrentSystemState(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CurrentSystemState(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn IgnoreHibernationPath(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IgnoreHibernationPath(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PseudoTransition(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PseudoTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelSoftReboot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelSoftReboot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirectedDripsTransition(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirectedDripsTransition(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: ULONG,
        TargetSystemState: ULONG,
        EffectiveSystemState: ULONG,
        CurrentSystemState: ULONG,
        IgnoreHibernationPath: ULONG,
        PseudoTransition: ULONG,
        KernelSoftReboot: ULONG,
        DirectedDripsTransition: ULONG,
        Reserved2: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                8u8,
                {
                    let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
                    Reserved1 as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                8usize,
                4u8,
                {
                    let TargetSystemState: u32 = unsafe {
                        ::core::mem::transmute(TargetSystemState)
                    };
                    TargetSystemState as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                12usize,
                4u8,
                {
                    let EffectiveSystemState: u32 = unsafe {
                        ::core::mem::transmute(EffectiveSystemState)
                    };
                    EffectiveSystemState as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                16usize,
                4u8,
                {
                    let CurrentSystemState: u32 = unsafe {
                        ::core::mem::transmute(CurrentSystemState)
                    };
                    CurrentSystemState as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                20usize,
                1u8,
                {
                    let IgnoreHibernationPath: u32 = unsafe {
                        ::core::mem::transmute(IgnoreHibernationPath)
                    };
                    IgnoreHibernationPath as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                21usize,
                1u8,
                {
                    let PseudoTransition: u32 = unsafe {
                        ::core::mem::transmute(PseudoTransition)
                    };
                    PseudoTransition as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                22usize,
                1u8,
                {
                    let KernelSoftReboot: u32 = unsafe {
                        ::core::mem::transmute(KernelSoftReboot)
                    };
                    KernelSoftReboot as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                23usize,
                1u8,
                {
                    let DirectedDripsTransition: u32 = unsafe {
                        ::core::mem::transmute(DirectedDripsTransition)
                    };
                    DirectedDripsTransition as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                24usize,
                8u8,
                {
                    let Reserved2: u32 = unsafe { ::core::mem::transmute(Reserved2) };
                    Reserved2 as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContextAsUlong) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(ContextAsUlong),
        ),
    );
}
impl Default for _SYSTEM_POWER_STATE_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_STATE_CONTEXT() {
    assert_eq!(
        ::core::mem::size_of::<_SYSTEM_POWER_STATE_CONTEXT>(),
        4usize,
        concat!("Size of: ", stringify!(_SYSTEM_POWER_STATE_CONTEXT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_SYSTEM_POWER_STATE_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_POWER_STATE_CONTEXT)),
    );
}
impl Default for _SYSTEM_POWER_STATE_CONTEXT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYSTEM_POWER_STATE_CONTEXT = _SYSTEM_POWER_STATE_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Flags: USHORT,
    pub u: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Generic: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Port: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub Interrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub MessageInterrupt: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub Memory: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Dma: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub DmaV3: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub DevicePrivate: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    pub BusNumber: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    pub DeviceSpecificData: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    pub Memory40: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    pub Memory48: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    pub Memory64: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
    pub Connection: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Start),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length),
        ),
    );
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Start),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Length),
        ),
    );
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
        >(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Level),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vector) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Vector),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Affinity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Affinity),
        ),
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub __bindgen_anon_1: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Raw: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub Translated: _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub Reserved: USHORT,
    pub MessageCount: USHORT,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
        >(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(Reserved),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MessageCount) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(MessageCount),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vector) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(Vector),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Affinity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(Affinity),
        ),
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub Level: ULONG,
    pub Vector: ULONG,
    pub Affinity: KAFFINITY,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
        >(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2
            ),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2
            ),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(Level),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vector) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(Vector),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Affinity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(Affinity),
        ),
    );
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
        >(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1
            ),
            "::",
            stringify!(Raw),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Translated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1
            ),
            "::",
            stringify!(Translated),
        ),
    );
}
impl Default
for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
        >(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4),
        ),
    );
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Start),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Length),
        ),
    );
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Channel: ULONG,
    pub Port: ULONG,
    pub Reserved1: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Channel),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Port),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Reserved1),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Channel: ULONG,
    pub RequestLine: ULONG,
    pub TransferWidth: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub Reserved3: UCHAR,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Channel),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RequestLine) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(RequestLine),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(TransferWidth),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Reserved1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Reserved2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Reserved3),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Data: [ULONG; 3usize],
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(Data),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Start: ULONG,
    pub Length: ULONG,
    pub Reserved: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Start),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Reserved),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub DataSize: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(DataSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Reserved1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Reserved2),
        ),
    );
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length40: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(Start),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length40) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(Length40),
        ),
    );
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length48: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Start),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length48) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Length48),
        ),
    );
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Start: PHYSICAL_ADDRESS,
    pub Length64: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Start),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length64) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Length64),
        ),
    );
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14,
        >(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Class),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Type),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Reserved1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Reserved2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IdLowPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(IdLowPart),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IdHighPart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(IdHighPart),
        ),
    );
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Generic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Generic),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Port),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Interrupt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Interrupt),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).MessageInterrupt) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(MessageInterrupt),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Memory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Dma) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Dma),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DmaV3) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(DmaV3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DevicePrivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(DevicePrivate),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BusNumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(BusNumber),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DeviceSpecificData) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(DeviceSpecificData),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Memory40) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory40),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Memory48) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory48),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Memory64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory64),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Connection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Connection),
        ),
    );
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_DESCRIPTOR() {
    const UNINIT: ::core::mem::MaybeUninit<_CM_PARTIAL_RESOURCE_DESCRIPTOR> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR>(),
        20usize,
        concat!("Size of: ", stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR)),
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Type),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ShareDisposition) as usize - ptr as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(ShareDisposition),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(u),
        ),
    );
}
impl Default for _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CM_PARTIAL_RESOURCE_DESCRIPTOR = _CM_PARTIAL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_PARTIAL_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub PartialDescriptors: [CM_PARTIAL_RESOURCE_DESCRIPTOR; 1usize],
}
#[test]
fn bindgen_test_layout__CM_PARTIAL_RESOURCE_LIST() {
    const UNINIT: ::core::mem::MaybeUninit<_CM_PARTIAL_RESOURCE_LIST> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CM_PARTIAL_RESOURCE_LIST>(),
        28usize,
        concat!("Size of: ", stringify!(_CM_PARTIAL_RESOURCE_LIST)),
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_PARTIAL_RESOURCE_LIST>(),
        4usize,
        concat!("Alignment of ", stringify!(_CM_PARTIAL_RESOURCE_LIST)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_LIST),
            "::",
            stringify!(Version),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_LIST),
            "::",
            stringify!(Revision),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_LIST),
            "::",
            stringify!(Count),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).PartialDescriptors) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_PARTIAL_RESOURCE_LIST),
            "::",
            stringify!(PartialDescriptors),
        ),
    );
}
impl Default for _CM_PARTIAL_RESOURCE_LIST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CM_PARTIAL_RESOURCE_LIST = _CM_PARTIAL_RESOURCE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_FULL_RESOURCE_DESCRIPTOR {
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub PartialResourceList: CM_PARTIAL_RESOURCE_LIST,
}
#[test]
fn bindgen_test_layout__CM_FULL_RESOURCE_DESCRIPTOR() {
    const UNINIT: ::core::mem::MaybeUninit<_CM_FULL_RESOURCE_DESCRIPTOR> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CM_FULL_RESOURCE_DESCRIPTOR>(),
        36usize,
        concat!("Size of: ", stringify!(_CM_FULL_RESOURCE_DESCRIPTOR)),
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_FULL_RESOURCE_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_CM_FULL_RESOURCE_DESCRIPTOR)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterfaceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_FULL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(InterfaceType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BusNumber) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_FULL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(BusNumber),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).PartialResourceList) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_FULL_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(PartialResourceList),
        ),
    );
}
impl Default for _CM_FULL_RESOURCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CM_FULL_RESOURCE_DESCRIPTOR = _CM_FULL_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CM_RESOURCE_LIST {
    pub Count: ULONG,
    pub List: [CM_FULL_RESOURCE_DESCRIPTOR; 1usize],
}
#[test]
fn bindgen_test_layout__CM_RESOURCE_LIST() {
    const UNINIT: ::core::mem::MaybeUninit<_CM_RESOURCE_LIST> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CM_RESOURCE_LIST>(),
        40usize,
        concat!("Size of: ", stringify!(_CM_RESOURCE_LIST)),
    );
    assert_eq!(
        ::core::mem::align_of::<_CM_RESOURCE_LIST>(),
        4usize,
        concat!("Alignment of ", stringify!(_CM_RESOURCE_LIST)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_RESOURCE_LIST),
            "::",
            stringify!(Count),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).List) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CM_RESOURCE_LIST),
            "::",
            stringify!(List),
        ),
    );
}
impl Default for _CM_RESOURCE_LIST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PCM_RESOURCE_LIST = *mut _CM_RESOURCE_LIST;
pub mod _IRQ_DEVICE_POLICY {
    pub type Type = ::core::ffi::c_int;
    pub const IrqPolicyMachineDefault: Type = 0;
    pub const IrqPolicyAllCloseProcessors: Type = 1;
    pub const IrqPolicyOneCloseProcessor: Type = 2;
    pub const IrqPolicyAllProcessorsInMachine: Type = 3;
    pub const IrqPolicySpecifiedProcessors: Type = 4;
    pub const IrqPolicySpreadMessagesAcrossAllProcessors: Type = 5;
    pub const IrqPolicyAllProcessorsInMachineWhenSteered: Type = 6;
}
pub use self::_IRQ_DEVICE_POLICY::Type as IRQ_DEVICE_POLICY;
pub mod _IRQ_PRIORITY {
    pub type Type = ::core::ffi::c_int;
    pub const IrqPriorityUndefined: Type = 0;
    pub const IrqPriorityLow: Type = 1;
    pub const IrqPriorityNormal: Type = 2;
    pub const IrqPriorityHigh: Type = 3;
}
pub use self::_IRQ_PRIORITY::Type as IRQ_PRIORITY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR {
    pub Option: UCHAR,
    pub Type: UCHAR,
    pub ShareDisposition: UCHAR,
    pub Spare1: UCHAR,
    pub Flags: USHORT,
    pub Spare2: USHORT,
    pub u: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    pub Port: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    pub Memory: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    pub Interrupt: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    pub Dma: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    pub DmaV3: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    pub Generic: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    pub DevicePrivate: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    pub BusNumber: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    pub ConfigData: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    pub Memory40: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    pub Memory48: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    pub Memory64: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    pub Connection: _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Alignment),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinimumAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(MinimumAddress),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(MaximumAddress),
        ),
    );
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Alignment),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinimumAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(MinimumAddress),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(MaximumAddress),
        ),
    );
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    pub MinimumVector: ULONG,
    pub MaximumVector: ULONG,
    pub AffinityPolicy: IRQ_DEVICE_POLICY,
    pub PriorityPolicy: IRQ_PRIORITY,
    pub TargetedProcessors: KAFFINITY,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinimumVector) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(MinimumVector),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumVector) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(MaximumVector),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AffinityPolicy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(AffinityPolicy),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PriorityPolicy) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(PriorityPolicy),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TargetedProcessors) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(TargetedProcessors),
        ),
    );
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4 {
    pub MinimumChannel: ULONG,
    pub MaximumChannel: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinimumChannel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(MinimumChannel),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumChannel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(MaximumChannel),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5 {
    pub RequestLine: ULONG,
    pub Reserved: ULONG,
    pub Channel: ULONG,
    pub TransferWidth: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RequestLine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(RequestLine),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Reserved),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Channel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Channel),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferWidth) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(TransferWidth),
        ),
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub Alignment: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Alignment),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinimumAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(MinimumAddress),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(MaximumAddress),
        ),
    );
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7 {
    pub Data: [ULONG; 3usize],
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Data),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub MinBusNumber: ULONG,
    pub MaxBusNumber: ULONG,
    pub Reserved: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinBusNumber) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(MinBusNumber),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaxBusNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(MaxBusNumber),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(Reserved),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9 {
    pub Priority: ULONG,
    pub Reserved1: ULONG,
    pub Reserved2: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Priority),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Reserved1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Reserved2),
        ),
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    pub Length40: ULONG,
    pub Alignment40: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length40) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Length40),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment40) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Alignment40),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinimumAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(MinimumAddress),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(MaximumAddress),
        ),
    );
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    pub Length48: ULONG,
    pub Alignment48: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length48) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(Length48),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment48) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(Alignment48),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinimumAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(MinimumAddress),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(MaximumAddress),
        ),
    );
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    pub Length64: ULONG,
    pub Alignment64: ULONG,
    pub MinimumAddress: PHYSICAL_ADDRESS,
    pub MaximumAddress: PHYSICAL_ADDRESS,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Length64),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment64) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Alignment64),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinimumAddress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(MinimumAddress),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(MaximumAddress),
        ),
    );
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13 {
    pub Class: UCHAR,
    pub Type: UCHAR,
    pub Reserved1: UCHAR,
    pub Reserved2: UCHAR,
    pub IdLowPart: ULONG,
    pub IdHighPart: ULONG,
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Class),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Type),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Reserved1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Reserved2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IdLowPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(IdLowPart),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IdHighPart) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(IdHighPart),
        ),
    );
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Port),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Memory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Interrupt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Interrupt),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Dma) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Dma),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DmaV3) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(DmaV3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Generic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Generic),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DevicePrivate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(DevicePrivate),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BusNumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(BusNumber),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ConfigData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(ConfigData),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Memory40) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory40),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Memory48) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory48),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Memory64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Memory64),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Connection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Connection),
        ),
    );
}
impl Default for _IO_RESOURCE_DESCRIPTOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_DESCRIPTOR() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_RESOURCE_DESCRIPTOR> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_DESCRIPTOR>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_RESOURCE_DESCRIPTOR)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_RESOURCE_DESCRIPTOR)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Option) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Option),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Type),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ShareDisposition) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(ShareDisposition),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Spare1) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Spare1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Spare2) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(Spare2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_DESCRIPTOR),
            "::",
            stringify!(u),
        ),
    );
}
impl Default for _IO_RESOURCE_DESCRIPTOR {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IO_RESOURCE_DESCRIPTOR = _IO_RESOURCE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_LIST {
    pub Version: USHORT,
    pub Revision: USHORT,
    pub Count: ULONG,
    pub Descriptors: [IO_RESOURCE_DESCRIPTOR; 1usize],
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_LIST() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_RESOURCE_LIST> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_LIST>(),
        40usize,
        concat!("Size of: ", stringify!(_IO_RESOURCE_LIST)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_RESOURCE_LIST)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_LIST),
            "::",
            stringify!(Version),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_LIST),
            "::",
            stringify!(Revision),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_LIST),
            "::",
            stringify!(Count),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Descriptors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_LIST),
            "::",
            stringify!(Descriptors),
        ),
    );
}
impl Default for _IO_RESOURCE_LIST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IO_RESOURCE_LIST = _IO_RESOURCE_LIST;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_RESOURCE_REQUIREMENTS_LIST {
    pub ListSize: ULONG,
    pub InterfaceType: INTERFACE_TYPE,
    pub BusNumber: ULONG,
    pub SlotNumber: ULONG,
    pub Reserved: [ULONG; 3usize],
    pub AlternativeLists: ULONG,
    pub List: [IO_RESOURCE_LIST; 1usize],
}
#[test]
fn bindgen_test_layout__IO_RESOURCE_REQUIREMENTS_LIST() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_RESOURCE_REQUIREMENTS_LIST> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_RESOURCE_REQUIREMENTS_LIST>(),
        72usize,
        concat!("Size of: ", stringify!(_IO_RESOURCE_REQUIREMENTS_LIST)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_RESOURCE_REQUIREMENTS_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_RESOURCE_REQUIREMENTS_LIST)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ListSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(ListSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterfaceType) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(InterfaceType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BusNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(BusNumber),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SlotNumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(SlotNumber),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(Reserved),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AlternativeLists) as usize - ptr as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(AlternativeLists),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).List) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_RESOURCE_REQUIREMENTS_LIST),
            "::",
            stringify!(List),
        ),
    );
}
impl Default for _IO_RESOURCE_REQUIREMENTS_LIST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PIO_RESOURCE_REQUIREMENTS_LIST = *mut _IO_RESOURCE_REQUIREMENTS_LIST;
pub type NOTIFICATION_MASK = ULONG;
pub use self::_POOL_TYPE::Type as POOL_TYPE;
pub type KPROCESSOR_MODE = CCHAR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC {
    pub Type: UCHAR,
    pub AllFlags: UCHAR,
    pub Size: UCHAR,
    pub SpareByte1: UCHAR,
    pub SpareLong0: ULONG,
    pub Thread: *mut _KTHREAD,
    pub ApcListEntry: LIST_ENTRY,
    pub Reserved: [PVOID; 3usize],
    pub NormalContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub ApcStateIndex: CCHAR,
    pub ApcMode: KPROCESSOR_MODE,
    pub Inserted: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KAPC() {
    const UNINIT: ::core::mem::MaybeUninit<_KAPC> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KAPC>(),
        88usize,
        concat!("Size of: ", stringify!(_KAPC)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC>(),
        8usize,
        concat!("Alignment of ", stringify!(_KAPC)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(Type)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllFlags) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(AllFlags)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(Size)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SpareByte1) as usize - ptr as usize },
        3usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(SpareByte1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SpareLong0) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(SpareLong0)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(Thread)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcListEntry) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(ApcListEntry)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(Reserved)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NormalContext) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(NormalContext)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument1) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(SystemArgument1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(SystemArgument2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcStateIndex) as usize - ptr as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(ApcStateIndex)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcMode) as usize - ptr as usize },
        81usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(ApcMode)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        82usize,
        concat!("Offset of field: ", stringify!(_KAPC), "::", stringify!(Inserted)),
    );
}
impl Default for _KAPC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KAPC = _KAPC;
pub type KDEFERRED_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        Dpc: *mut _KDPC,
        DeferredContext: PVOID,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
    ),
>;
pub type PKDEFERRED_ROUTINE = KDEFERRED_ROUTINE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDPC {
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1,
    pub DpcListEntry: SINGLE_LIST_ENTRY,
    pub ProcessorHistory: KAFFINITY,
    pub DeferredRoutine: PKDEFERRED_ROUTINE,
    pub DeferredContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
    pub DpcData: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDPC__bindgen_ty_1 {
    pub TargetInfoAsUlong: ULONG,
    pub __bindgen_anon_1: _KDPC__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KDPC__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Importance: UCHAR,
    pub Number: USHORT,
}
#[test]
fn bindgen_test_layout__KDPC__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_KDPC__bindgen_ty_1__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDPC__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_KDPC__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KDPC__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_KDPC__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Type),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Importance) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Importance),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Number) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Number),
        ),
    );
}
#[test]
fn bindgen_test_layout__KDPC__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_KDPC__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDPC__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_KDPC__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KDPC__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDPC__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TargetInfoAsUlong) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC__bindgen_ty_1),
            "::",
            stringify!(TargetInfoAsUlong),
        ),
    );
}
impl Default for _KDPC__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__KDPC() {
    const UNINIT: ::core::mem::MaybeUninit<_KDPC> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDPC>(),
        64usize,
        concat!("Size of: ", stringify!(_KDPC)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KDPC>(),
        8usize,
        concat!("Alignment of ", stringify!(_KDPC)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DpcListEntry) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_KDPC), "::", stringify!(DpcListEntry)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ProcessorHistory) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(ProcessorHistory),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeferredRoutine) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DeferredRoutine),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeferredContext) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DeferredContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument1) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(SystemArgument1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument2) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(SystemArgument2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DpcData) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(_KDPC), "::", stringify!(DpcData)),
    );
}
impl Default for _KDPC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KDPC = _KDPC;
pub type PKDPC = *mut _KDPC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MDL {
    pub Next: *mut _MDL,
    pub Size: CSHORT,
    pub MdlFlags: CSHORT,
    pub Process: *mut _EPROCESS,
    pub MappedSystemVa: PVOID,
    pub StartVa: PVOID,
    pub ByteCount: ULONG,
    pub ByteOffset: ULONG,
}
#[test]
fn bindgen_test_layout__MDL() {
    const UNINIT: ::core::mem::MaybeUninit<_MDL> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MDL>(),
        48usize,
        concat!("Size of: ", stringify!(_MDL)),
    );
    assert_eq!(
        ::core::mem::align_of::<_MDL>(),
        8usize,
        concat!("Alignment of ", stringify!(_MDL)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(Next)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(Size)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlFlags) as usize - ptr as usize },
        10usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(MdlFlags)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Process) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(Process)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MappedSystemVa) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(MappedSystemVa)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartVa) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(StartVa)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ByteCount) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(ByteCount)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ByteOffset) as usize - ptr as usize },
        44usize,
        concat!("Offset of field: ", stringify!(_MDL), "::", stringify!(ByteOffset)),
    );
}
impl Default for _MDL {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PMDL = *mut _MDL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1 {
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6,
    pub __bindgen_anon_7: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    pub Lock: LONG,
    pub LockNV: LONG,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Lock),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockNV) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LockNV),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2 {
    pub Type: UCHAR,
    pub Signalling: UCHAR,
    pub Size: UCHAR,
    pub Reserved1: UCHAR,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Type),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Signalling) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Signalling),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Reserved1),
        ),
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 {
    pub TimerType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub Hand: UCHAR,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub TimerControlFlags: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Absolute(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Absolute(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Wake(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Wake(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EncodedTolerableDelay(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_EncodedTolerableDelay(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Absolute: UCHAR,
        Wake: UCHAR,
        EncodedTolerableDelay: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                1u8,
                {
                    let Absolute: u8 = unsafe { ::core::mem::transmute(Absolute) };
                    Absolute as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                1usize,
                1u8,
                {
                    let Wake: u8 = unsafe { ::core::mem::transmute(Wake) };
                    Wake as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                2usize,
                6u8,
                {
                    let EncodedTolerableDelay: u8 = unsafe {
                        ::core::mem::transmute(EncodedTolerableDelay)
                    };
                    EncodedTolerableDelay as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TimerControlFlags) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(TimerControlFlags),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub TimerMiscFlags: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1
            ),
        ),
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn Index(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_Index(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn Inserted(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Expired(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Expired(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Index: UCHAR,
        Inserted: UCHAR,
        Expired: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                6u8,
                {
                    let Index: u8 = unsafe { ::core::mem::transmute(Index) };
                    Index as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                6usize,
                1u8,
                {
                    let Inserted: u8 = unsafe { ::core::mem::transmute(Inserted) };
                    Inserted as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                7usize,
                1u8,
                {
                    let Expired: u8 = unsafe { ::core::mem::transmute(Expired) };
                    Expired as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerMiscFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(TimerMiscFlags),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(TimerType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hand) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Hand),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 {
    pub Timer2Type: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub Timer2ComponentId: UCHAR,
    pub Timer2RelativeId: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub Timer2Flags: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Timer2Inserted(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Inserted(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2Expiring(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Expiring(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2CancelPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2CancelPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2SetPending(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2SetPending(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2Running(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Running(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2Disabled(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2Disabled(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Timer2ReservedFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Timer2ReservedFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Timer2Inserted: UCHAR,
        Timer2Expiring: UCHAR,
        Timer2CancelPending: UCHAR,
        Timer2SetPending: UCHAR,
        Timer2Running: UCHAR,
        Timer2Disabled: UCHAR,
        Timer2ReservedFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                1u8,
                {
                    let Timer2Inserted: u8 = unsafe {
                        ::core::mem::transmute(Timer2Inserted)
                    };
                    Timer2Inserted as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                1usize,
                1u8,
                {
                    let Timer2Expiring: u8 = unsafe {
                        ::core::mem::transmute(Timer2Expiring)
                    };
                    Timer2Expiring as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                2usize,
                1u8,
                {
                    let Timer2CancelPending: u8 = unsafe {
                        ::core::mem::transmute(Timer2CancelPending)
                    };
                    Timer2CancelPending as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                3usize,
                1u8,
                {
                    let Timer2SetPending: u8 = unsafe {
                        ::core::mem::transmute(Timer2SetPending)
                    };
                    Timer2SetPending as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                1u8,
                {
                    let Timer2Running: u8 = unsafe {
                        ::core::mem::transmute(Timer2Running)
                    };
                    Timer2Running as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                5usize,
                1u8,
                {
                    let Timer2Disabled: u8 = unsafe {
                        ::core::mem::transmute(Timer2Disabled)
                    };
                    Timer2Disabled as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                6usize,
                2u8,
                {
                    let Timer2ReservedFlags: u8 = unsafe {
                        ::core::mem::transmute(Timer2ReservedFlags)
                    };
                    Timer2ReservedFlags as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timer2Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(Timer2Flags),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timer2Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Timer2Type),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).Timer2ComponentId) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Timer2ComponentId),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).Timer2RelativeId) as usize - ptr as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Timer2RelativeId),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 {
    pub QueueType: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    pub QueueSize: UCHAR,
    pub QueueReserved: UCHAR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub QueueControlFlags: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Abandoned(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Abandoned(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableIncrement(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DisableIncrement(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QueueReservedControlFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_QueueReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Abandoned: UCHAR,
        DisableIncrement: UCHAR,
        QueueReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                1u8,
                {
                    let Abandoned: u8 = unsafe { ::core::mem::transmute(Abandoned) };
                    Abandoned as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                1usize,
                1u8,
                {
                    let DisableIncrement: u8 = unsafe {
                        ::core::mem::transmute(DisableIncrement)
                    };
                    DisableIncrement as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                2usize,
                6u8,
                {
                    let QueueReservedControlFlags: u8 = unsafe {
                        ::core::mem::transmute(QueueReservedControlFlags)
                    };
                    QueueReservedControlFlags as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).QueueControlFlags) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(QueueControlFlags),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueueType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(QueueType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueueSize) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(QueueSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueueReserved) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(QueueReserved),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 {
    pub ThreadType: UCHAR,
    pub ThreadReserved: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub __bindgen_anon_2: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub ThreadControlFlags: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn CycleProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CycleProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CounterProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CounterProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GroupScheduling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GroupScheduling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AffinitySet(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AffinitySet(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Tagged(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Tagged(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnergyProfiling(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EnergyProfiling(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SchedulerAssist(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SchedulerAssist(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ThreadReservedControlFlags(&self) -> UCHAR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ThreadReservedControlFlags(&mut self, val: UCHAR) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CycleProfiling: UCHAR,
        CounterProfiling: UCHAR,
        GroupScheduling: UCHAR,
        AffinitySet: UCHAR,
        Tagged: UCHAR,
        EnergyProfiling: UCHAR,
        SchedulerAssist: UCHAR,
        ThreadReservedControlFlags: UCHAR,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                1u8,
                {
                    let CycleProfiling: u8 = unsafe {
                        ::core::mem::transmute(CycleProfiling)
                    };
                    CycleProfiling as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                1usize,
                1u8,
                {
                    let CounterProfiling: u8 = unsafe {
                        ::core::mem::transmute(CounterProfiling)
                    };
                    CounterProfiling as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                2usize,
                1u8,
                {
                    let GroupScheduling: u8 = unsafe {
                        ::core::mem::transmute(GroupScheduling)
                    };
                    GroupScheduling as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                3usize,
                1u8,
                {
                    let AffinitySet: u8 = unsafe { ::core::mem::transmute(AffinitySet) };
                    AffinitySet as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                1u8,
                {
                    let Tagged: u8 = unsafe { ::core::mem::transmute(Tagged) };
                    Tagged as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                5usize,
                1u8,
                {
                    let EnergyProfiling: u8 = unsafe {
                        ::core::mem::transmute(EnergyProfiling)
                    };
                    EnergyProfiling as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                6usize,
                1u8,
                {
                    let SchedulerAssist: u8 = unsafe {
                        ::core::mem::transmute(SchedulerAssist)
                    };
                    SchedulerAssist as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                7usize,
                1u8,
                {
                    let ThreadReservedControlFlags: u8 = unsafe {
                        ::core::mem::transmute(ThreadReservedControlFlags)
                    };
                    ThreadReservedControlFlags as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ThreadControlFlags) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1),
            "::",
            stringify!(ThreadControlFlags),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 {
    pub DebugActive: UCHAR,
    pub __bindgen_anon_1: _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1
            ),
        ),
    );
}
impl _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn ActiveDR7(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ActiveDR7(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Instrumented(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Instrumented(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Minimal(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Minimal(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved4(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved4(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn AltSyscall(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AltSyscall(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Emulation(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Emulation(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved5(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved5(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ActiveDR7: BOOLEAN,
        Instrumented: BOOLEAN,
        Minimal: BOOLEAN,
        Reserved4: BOOLEAN,
        AltSyscall: BOOLEAN,
        Emulation: BOOLEAN,
        Reserved5: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                1u8,
                {
                    let ActiveDR7: u8 = unsafe { ::core::mem::transmute(ActiveDR7) };
                    ActiveDR7 as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                1usize,
                1u8,
                {
                    let Instrumented: u8 = unsafe {
                        ::core::mem::transmute(Instrumented)
                    };
                    Instrumented as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                2usize,
                1u8,
                {
                    let Minimal: u8 = unsafe { ::core::mem::transmute(Minimal) };
                    Minimal as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                3usize,
                2u8,
                {
                    let Reserved4: u8 = unsafe { ::core::mem::transmute(Reserved4) };
                    Reserved4 as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                5usize,
                1u8,
                {
                    let AltSyscall: u8 = unsafe { ::core::mem::transmute(AltSyscall) };
                    AltSyscall as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                6usize,
                1u8,
                {
                    let Emulation: u8 = unsafe { ::core::mem::transmute(Emulation) };
                    Emulation as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                7usize,
                1u8,
                {
                    let Reserved5: u8 = unsafe { ::core::mem::transmute(Reserved5) };
                    Reserved5 as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DebugActive) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2),
            "::",
            stringify!(DebugActive),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(ThreadType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadReserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(ThreadReserved),
        ),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7 {
    pub MutantType: UCHAR,
    pub MutantSize: UCHAR,
    pub DpcActive: BOOLEAN,
    pub MutantReserved: UCHAR,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::core::mem::MaybeUninit<
        _DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MutantType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(MutantType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MutantSize) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(MutantSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DpcActive) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(DpcActive),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MutantReserved) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(MutantReserved),
        ),
    );
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_DISPATCHER_HEADER__bindgen_ty_1)),
    );
}
impl Default for _DISPATCHER_HEADER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_DISPATCHER_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER>(),
        24usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER>(),
        8usize,
        concat!("Alignment of ", stringify!(_DISPATCHER_HEADER)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SignalState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(SignalState),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(WaitListHead),
        ),
    );
}
impl Default for _DISPATCHER_HEADER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type DISPATCHER_HEADER = _DISPATCHER_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KEVENT {
    pub Header: DISPATCHER_HEADER,
}
#[test]
fn bindgen_test_layout__KEVENT() {
    const UNINIT: ::core::mem::MaybeUninit<_KEVENT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KEVENT>(),
        24usize,
        concat!("Size of: ", stringify!(_KEVENT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KEVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(_KEVENT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_KEVENT), "::", stringify!(Header)),
    );
}
impl Default for _KEVENT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KEVENT = _KEVENT;
pub type PKEVENT = *mut _KEVENT;
pub mod _LOCK_OPERATION {
    pub type Type = ::core::ffi::c_int;
    pub const IoReadAccess: Type = 0;
    pub const IoWriteAccess: Type = 1;
    pub const IoModifyAccess: Type = 2;
}
pub use self::_LOCK_OPERATION::Type as LOCK_OPERATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KWAIT_BLOCK {
    pub WaitListEntry: LIST_ENTRY,
    pub WaitType: UCHAR,
    pub BlockState: UCHAR,
    pub WaitKey: USHORT,
    pub SpareLong: LONG,
    pub __bindgen_anon_1: _KWAIT_BLOCK__bindgen_ty_1,
    pub Object: PVOID,
    pub SparePtr: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KWAIT_BLOCK__bindgen_ty_1 {
    pub Thread: *mut _KTHREAD,
    pub NotificationQueue: *mut _KQUEUE,
    pub Dpc: *mut _KDPC,
}
#[test]
fn bindgen_test_layout__KWAIT_BLOCK__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_KWAIT_BLOCK__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KWAIT_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_KWAIT_BLOCK__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KWAIT_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_KWAIT_BLOCK__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Thread),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NotificationQueue) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK__bindgen_ty_1),
            "::",
            stringify!(NotificationQueue),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Dpc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Dpc),
        ),
    );
}
impl Default for _KWAIT_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__KWAIT_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_KWAIT_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KWAIT_BLOCK>(),
        48usize,
        concat!("Size of: ", stringify!(_KWAIT_BLOCK)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KWAIT_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_KWAIT_BLOCK)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitListEntry),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitType) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BlockState) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(BlockState),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitKey) as usize - ptr as usize },
        18usize,
        concat!("Offset of field: ", stringify!(_KWAIT_BLOCK), "::", stringify!(WaitKey)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SpareLong) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(SpareLong),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Object) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_KWAIT_BLOCK), "::", stringify!(Object)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SparePtr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(SparePtr),
        ),
    );
}
impl Default for _KWAIT_BLOCK {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PKWAIT_BLOCK = *mut _KWAIT_BLOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KDEVICE_QUEUE {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceListHead: LIST_ENTRY,
    pub Lock: KSPIN_LOCK,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KDEVICE_QUEUE__bindgen_ty_1 {
    pub Busy: BOOLEAN,
    pub __bindgen_anon_1: _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1)),
    );
}
impl _KDEVICE_QUEUE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved(&self) -> LONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Hint(&self) -> LONG64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Hint(&mut self, val: LONG64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved: LONG64,
        Hint: LONG64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                8u8,
                {
                    let Reserved: u64 = unsafe { ::core::mem::transmute(Reserved) };
                    Reserved as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                8usize,
                56u8,
                {
                    let Hint: u64 = unsafe { ::core::mem::transmute(Hint) };
                    Hint as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_KDEVICE_QUEUE__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Busy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE__bindgen_ty_1),
            "::",
            stringify!(Busy),
        ),
    );
}
impl Default for _KDEVICE_QUEUE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE() {
    const UNINIT: ::core::mem::MaybeUninit<_KDEVICE_QUEUE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE>(),
        40usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE>(),
        8usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_KDEVICE_QUEUE), "::", stringify!(Type)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_KDEVICE_QUEUE), "::", stringify!(Size)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(DeviceListHead),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_KDEVICE_QUEUE), "::", stringify!(Lock)),
    );
}
impl Default for _KDEVICE_QUEUE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KDEVICE_QUEUE = _KDEVICE_QUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE_ENTRY {
    pub DeviceListEntry: LIST_ENTRY,
    pub SortKey: ULONG,
    pub Inserted: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_KDEVICE_QUEUE_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE_ENTRY>(),
        24usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE_ENTRY)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE_ENTRY)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(DeviceListEntry),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SortKey) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(SortKey),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(Inserted),
        ),
    );
}
impl Default for _KDEVICE_QUEUE_ENTRY {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type KDEVICE_QUEUE_ENTRY = _KDEVICE_QUEUE_ENTRY;
pub mod _POOL_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const NonPagedPool: Type = 0;
    pub const NonPagedPoolExecute: Type = 0;
    pub const PagedPool: Type = 1;
    pub const NonPagedPoolMustSucceed: Type = 2;
    pub const DontUseThisType: Type = 3;
    pub const NonPagedPoolCacheAligned: Type = 4;
    pub const PagedPoolCacheAligned: Type = 5;
    pub const NonPagedPoolCacheAlignedMustS: Type = 6;
    pub const MaxPoolType: Type = 7;
    pub const NonPagedPoolBase: Type = 0;
    pub const NonPagedPoolBaseMustSucceed: Type = 2;
    pub const NonPagedPoolBaseCacheAligned: Type = 4;
    pub const NonPagedPoolBaseCacheAlignedMustS: Type = 6;
    pub const NonPagedPoolSession: Type = 32;
    pub const PagedPoolSession: Type = 33;
    pub const NonPagedPoolMustSucceedSession: Type = 34;
    pub const DontUseThisTypeSession: Type = 35;
    pub const NonPagedPoolCacheAlignedSession: Type = 36;
    pub const PagedPoolCacheAlignedSession: Type = 37;
    pub const NonPagedPoolCacheAlignedMustSSession: Type = 38;
    pub const NonPagedPoolNx: Type = 512;
    pub const NonPagedPoolNxCacheAligned: Type = 516;
    pub const NonPagedPoolSessionNx: Type = 544;
}
pub mod _WORK_QUEUE_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const CriticalWorkQueue: Type = 0;
    pub const DelayedWorkQueue: Type = 1;
    pub const HyperCriticalWorkQueue: Type = 2;
    pub const NormalWorkQueue: Type = 3;
    pub const BackgroundWorkQueue: Type = 4;
    pub const RealTimeWorkQueue: Type = 5;
    pub const SuperCriticalWorkQueue: Type = 6;
    pub const MaximumWorkQueue: Type = 7;
    pub const CustomPriorityWorkQueue: Type = 32;
}
pub use self::_WORK_QUEUE_TYPE::Type as WORK_QUEUE_TYPE;
pub type ERESOURCE_THREAD = ULONG_PTR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OWNER_ENTRY {
    pub OwnerThread: ERESOURCE_THREAD,
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OWNER_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub TableSize: ULONG,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1)),
    );
}
impl _OWNER_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn IoPriorityBoosted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnerReferenced(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerReferenced(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoQoSPriorityBoosted(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoQoSPriorityBoosted(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OwnerCount(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_OwnerCount(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IoPriorityBoosted: ULONG,
        OwnerReferenced: ULONG,
        IoQoSPriorityBoosted: ULONG,
        OwnerCount: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                1u8,
                {
                    let IoPriorityBoosted: u32 = unsafe {
                        ::core::mem::transmute(IoPriorityBoosted)
                    };
                    IoPriorityBoosted as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                1usize,
                1u8,
                {
                    let OwnerReferenced: u32 = unsafe {
                        ::core::mem::transmute(OwnerReferenced)
                    };
                    OwnerReferenced as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                2usize,
                1u8,
                {
                    let IoQoSPriorityBoosted: u32 = unsafe {
                        ::core::mem::transmute(IoQoSPriorityBoosted)
                    };
                    IoQoSPriorityBoosted as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                3usize,
                29u8,
                {
                    let OwnerCount: u32 = unsafe { ::core::mem::transmute(OwnerCount) };
                    OwnerCount as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__OWNER_ENTRY__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_OWNER_ENTRY__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OWNER_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_OWNER_ENTRY__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_OWNER_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_OWNER_ENTRY__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TableSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OWNER_ENTRY__bindgen_ty_1),
            "::",
            stringify!(TableSize),
        ),
    );
}
impl Default for _OWNER_ENTRY__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__OWNER_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_OWNER_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OWNER_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_OWNER_ENTRY)),
    );
    assert_eq!(
        ::core::mem::align_of::<_OWNER_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_OWNER_ENTRY)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnerThread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OWNER_ENTRY),
            "::",
            stringify!(OwnerThread),
        ),
    );
}
impl Default for _OWNER_ENTRY {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type OWNER_ENTRY = _OWNER_ENTRY;
pub type POWNER_ENTRY = *mut _OWNER_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ERESOURCE {
    pub SystemResourcesList: LIST_ENTRY,
    pub OwnerTable: POWNER_ENTRY,
    pub ActiveCount: SHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1,
    pub SharedWaiters: PVOID,
    pub ExclusiveWaiters: PVOID,
    pub OwnerEntry: OWNER_ENTRY,
    pub ActiveEntries: ULONG,
    pub ContentionCount: ULONG,
    pub NumberOfSharedWaiters: ULONG,
    pub NumberOfExclusiveWaiters: ULONG,
    pub Reserved2: PVOID,
    pub __bindgen_anon_2: _ERESOURCE__bindgen_ty_2,
    pub SpinLock: KSPIN_LOCK,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_1 {
    pub Flag: USHORT,
    pub __bindgen_anon_1: _ERESOURCE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ERESOURCE__bindgen_ty_1__bindgen_ty_1 {
    pub ReservedLowFlags: UCHAR,
    pub WaiterPriority: UCHAR,
}
#[test]
fn bindgen_test_layout__ERESOURCE__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ERESOURCE__bindgen_ty_1__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ERESOURCE__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(_ERESOURCE__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_ERESOURCE__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(_ERESOURCE__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ReservedLowFlags) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ReservedLowFlags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaiterPriority) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(WaiterPriority),
        ),
    );
}
#[test]
fn bindgen_test_layout__ERESOURCE__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ERESOURCE__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ERESOURCE__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(_ERESOURCE__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_ERESOURCE__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_ERESOURCE__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE__bindgen_ty_1),
            "::",
            stringify!(Flag),
        ),
    );
}
impl Default for _ERESOURCE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ERESOURCE__bindgen_ty_2 {
    pub Address: PVOID,
    pub CreatorBackTraceIndex: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__ERESOURCE__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_ERESOURCE__bindgen_ty_2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ERESOURCE__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ERESOURCE__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_ERESOURCE__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_ERESOURCE__bindgen_ty_2)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE__bindgen_ty_2),
            "::",
            stringify!(Address),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CreatorBackTraceIndex) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE__bindgen_ty_2),
            "::",
            stringify!(CreatorBackTraceIndex),
        ),
    );
}
impl Default for _ERESOURCE__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__ERESOURCE() {
    const UNINIT: ::core::mem::MaybeUninit<_ERESOURCE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ERESOURCE>(),
        104usize,
        concat!("Size of: ", stringify!(_ERESOURCE)),
    );
    assert_eq!(
        ::core::mem::align_of::<_ERESOURCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_ERESOURCE)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SystemResourcesList) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(SystemResourcesList),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnerTable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(OwnerTable),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ActiveCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(ActiveCount),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedWaiters) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(SharedWaiters),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ExclusiveWaiters) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(ExclusiveWaiters),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnerEntry) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(OwnerEntry),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ActiveEntries) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(ActiveEntries),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContentionCount) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(ContentionCount),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NumberOfSharedWaiters) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(NumberOfSharedWaiters),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NumberOfExclusiveWaiters) as usize
                - ptr as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERESOURCE),
            "::",
            stringify!(NumberOfExclusiveWaiters),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_ERESOURCE), "::", stringify!(Reserved2)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SpinLock) as usize - ptr as usize },
        96usize,
        concat!("Offset of field: ", stringify!(_ERESOURCE), "::", stringify!(SpinLock)),
    );
}
impl Default for _ERESOURCE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PERESOURCE = *mut _ERESOURCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_SUBJECT_CONTEXT {
    pub ClientToken: PACCESS_TOKEN,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub PrimaryToken: PACCESS_TOKEN,
    pub ProcessAuditId: PVOID,
}
#[test]
fn bindgen_test_layout__SECURITY_SUBJECT_CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_SECURITY_SUBJECT_CONTEXT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SECURITY_SUBJECT_CONTEXT>(),
        32usize,
        concat!("Size of: ", stringify!(_SECURITY_SUBJECT_CONTEXT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_SECURITY_SUBJECT_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_SECURITY_SUBJECT_CONTEXT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClientToken) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_SUBJECT_CONTEXT),
            "::",
            stringify!(ClientToken),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ImpersonationLevel) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_SUBJECT_CONTEXT),
            "::",
            stringify!(ImpersonationLevel),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrimaryToken) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_SUBJECT_CONTEXT),
            "::",
            stringify!(PrimaryToken),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ProcessAuditId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_SUBJECT_CONTEXT),
            "::",
            stringify!(ProcessAuditId),
        ),
    );
}
impl Default for _SECURITY_SUBJECT_CONTEXT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SECURITY_SUBJECT_CONTEXT = _SECURITY_SUBJECT_CONTEXT;
pub type PSECURITY_SUBJECT_CONTEXT = *mut _SECURITY_SUBJECT_CONTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _INITIAL_PRIVILEGE_SET {
    pub PrivilegeCount: ULONG,
    pub Control: ULONG,
    pub Privilege: [LUID_AND_ATTRIBUTES; 3usize],
}
#[test]
fn bindgen_test_layout__INITIAL_PRIVILEGE_SET() {
    const UNINIT: ::core::mem::MaybeUninit<_INITIAL_PRIVILEGE_SET> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_INITIAL_PRIVILEGE_SET>(),
        44usize,
        concat!("Size of: ", stringify!(_INITIAL_PRIVILEGE_SET)),
    );
    assert_eq!(
        ::core::mem::align_of::<_INITIAL_PRIVILEGE_SET>(),
        4usize,
        concat!("Alignment of ", stringify!(_INITIAL_PRIVILEGE_SET)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrivilegeCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_INITIAL_PRIVILEGE_SET),
            "::",
            stringify!(PrivilegeCount),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Control) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_INITIAL_PRIVILEGE_SET),
            "::",
            stringify!(Control),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Privilege) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_INITIAL_PRIVILEGE_SET),
            "::",
            stringify!(Privilege),
        ),
    );
}
pub type INITIAL_PRIVILEGE_SET = _INITIAL_PRIVILEGE_SET;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACCESS_STATE {
    pub OperationID: LUID,
    pub SecurityEvaluated: BOOLEAN,
    pub GenerateAudit: BOOLEAN,
    pub GenerateOnClose: BOOLEAN,
    pub PrivilegesAllocated: BOOLEAN,
    pub Flags: ULONG,
    pub RemainingDesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub OriginalDesiredAccess: ACCESS_MASK,
    pub SubjectSecurityContext: SECURITY_SUBJECT_CONTEXT,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub AuxData: PVOID,
    pub Privileges: _ACCESS_STATE__bindgen_ty_1,
    pub AuditPrivileges: BOOLEAN,
    pub ObjectName: UNICODE_STRING,
    pub ObjectTypeName: UNICODE_STRING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ACCESS_STATE__bindgen_ty_1 {
    pub InitialPrivilegeSet: INITIAL_PRIVILEGE_SET,
    pub PrivilegeSet: PRIVILEGE_SET,
}
#[test]
fn bindgen_test_layout__ACCESS_STATE__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ACCESS_STATE__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ACCESS_STATE__bindgen_ty_1>(),
        44usize,
        concat!("Size of: ", stringify!(_ACCESS_STATE__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_ACCESS_STATE__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_STATE__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InitialPrivilegeSet) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE__bindgen_ty_1),
            "::",
            stringify!(InitialPrivilegeSet),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrivilegeSet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE__bindgen_ty_1),
            "::",
            stringify!(PrivilegeSet),
        ),
    );
}
impl Default for _ACCESS_STATE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__ACCESS_STATE() {
    const UNINIT: ::core::mem::MaybeUninit<_ACCESS_STATE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ACCESS_STATE>(),
        160usize,
        concat!("Size of: ", stringify!(_ACCESS_STATE)),
    );
    assert_eq!(
        ::core::mem::align_of::<_ACCESS_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(_ACCESS_STATE)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OperationID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(OperationID),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityEvaluated) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(SecurityEvaluated),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenerateAudit) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(GenerateAudit),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenerateOnClose) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(GenerateOnClose),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).PrivilegesAllocated) as usize - ptr as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(PrivilegesAllocated),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(_ACCESS_STATE), "::", stringify!(Flags)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).RemainingDesiredAccess) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(RemainingDesiredAccess),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).PreviouslyGrantedAccess) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(PreviouslyGrantedAccess),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OriginalDesiredAccess) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(OriginalDesiredAccess),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SubjectSecurityContext) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(SubjectSecurityContext),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(SecurityDescriptor),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AuxData) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(AuxData),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Privileges) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(Privileges),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AuditPrivileges) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(AuditPrivileges),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectName) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(ObjectName),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectTypeName) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_STATE),
            "::",
            stringify!(ObjectTypeName),
        ),
    );
}
impl Default for _ACCESS_STATE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NAMED_PIPE_CREATE_PARAMETERS {
    pub NamedPipeType: ULONG,
    pub ReadMode: ULONG,
    pub CompletionMode: ULONG,
    pub MaximumInstances: ULONG,
    pub InboundQuota: ULONG,
    pub OutboundQuota: ULONG,
    pub DefaultTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
#[test]
fn bindgen_test_layout__NAMED_PIPE_CREATE_PARAMETERS() {
    const UNINIT: ::core::mem::MaybeUninit<_NAMED_PIPE_CREATE_PARAMETERS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_NAMED_PIPE_CREATE_PARAMETERS>(),
        40usize,
        concat!("Size of: ", stringify!(_NAMED_PIPE_CREATE_PARAMETERS)),
    );
    assert_eq!(
        ::core::mem::align_of::<_NAMED_PIPE_CREATE_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_NAMED_PIPE_CREATE_PARAMETERS)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(NamedPipeType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(ReadMode),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(CompletionMode),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).MaximumInstances) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(MaximumInstances),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InboundQuota) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(InboundQuota),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutboundQuota) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(OutboundQuota),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DefaultTimeout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(DefaultTimeout),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TimeoutSpecified) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_NAMED_PIPE_CREATE_PARAMETERS),
            "::",
            stringify!(TimeoutSpecified),
        ),
    );
}
impl Default for _NAMED_PIPE_CREATE_PARAMETERS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PNAMED_PIPE_CREATE_PARAMETERS = *mut _NAMED_PIPE_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MAILSLOT_CREATE_PARAMETERS {
    pub MailslotQuota: ULONG,
    pub MaximumMessageSize: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
    pub TimeoutSpecified: BOOLEAN,
}
#[test]
fn bindgen_test_layout__MAILSLOT_CREATE_PARAMETERS() {
    const UNINIT: ::core::mem::MaybeUninit<_MAILSLOT_CREATE_PARAMETERS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MAILSLOT_CREATE_PARAMETERS>(),
        24usize,
        concat!("Size of: ", stringify!(_MAILSLOT_CREATE_PARAMETERS)),
    );
    assert_eq!(
        ::core::mem::align_of::<_MAILSLOT_CREATE_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_MAILSLOT_CREATE_PARAMETERS)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MailslotQuota) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MAILSLOT_CREATE_PARAMETERS),
            "::",
            stringify!(MailslotQuota),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).MaximumMessageSize) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MAILSLOT_CREATE_PARAMETERS),
            "::",
            stringify!(MaximumMessageSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadTimeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MAILSLOT_CREATE_PARAMETERS),
            "::",
            stringify!(ReadTimeout),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TimeoutSpecified) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MAILSLOT_CREATE_PARAMETERS),
            "::",
            stringify!(TimeoutSpecified),
        ),
    );
}
impl Default for _MAILSLOT_CREATE_PARAMETERS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PMAILSLOT_CREATE_PARAMETERS = *mut _MAILSLOT_CREATE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCSI_REQUEST_BLOCK {
    _unused: [u8; 0],
}
pub type DRIVER_INITIALIZE = ::core::option::Option<
    unsafe extern "C" fn(
        DriverObject: *mut _DRIVER_OBJECT,
        RegistryPath: PUNICODE_STRING,
    ) -> NTSTATUS,
>;
pub type PDRIVER_INITIALIZE = DRIVER_INITIALIZE;
pub type DRIVER_CANCEL = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP),
>;
pub type PDRIVER_CANCEL = DRIVER_CANCEL;
pub type DRIVER_DISPATCH = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP) -> NTSTATUS,
>;
pub type PDRIVER_DISPATCH = DRIVER_DISPATCH;
pub type DRIVER_STARTIO = ::core::option::Option<
    unsafe extern "C" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP),
>;
pub type PDRIVER_STARTIO = DRIVER_STARTIO;
pub type DRIVER_UNLOAD = ::core::option::Option<
    unsafe extern "C" fn(DriverObject: *mut _DRIVER_OBJECT),
>;
pub type PDRIVER_UNLOAD = DRIVER_UNLOAD;
pub type DRIVER_ADD_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(
        DriverObject: *mut _DRIVER_OBJECT,
        PhysicalDeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PDRIVER_ADD_DEVICE = DRIVER_ADD_DEVICE;
pub type FAST_IO_CHECK_IF_POSSIBLE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        CheckForReadOperation: BOOLEAN,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_CHECK_IF_POSSIBLE = FAST_IO_CHECK_IF_POSSIBLE;
pub type FAST_IO_READ = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_READ = FAST_IO_READ;
pub type FAST_IO_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        Wait: BOOLEAN,
        LockKey: ULONG,
        Buffer: PVOID,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_WRITE = FAST_IO_WRITE;
pub type FAST_IO_QUERY_BASIC_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: PFILE_BASIC_INFORMATION,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_BASIC_INFO = FAST_IO_QUERY_BASIC_INFO;
pub type FAST_IO_QUERY_STANDARD_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: PFILE_STANDARD_INFORMATION,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_STANDARD_INFO = FAST_IO_QUERY_STANDARD_INFO;
pub type FAST_IO_LOCK = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        FailImmediately: BOOLEAN,
        ExclusiveLock: BOOLEAN,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_LOCK = FAST_IO_LOCK;
pub type FAST_IO_UNLOCK_SINGLE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: PLARGE_INTEGER,
        ProcessId: PEPROCESS,
        Key: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_SINGLE = FAST_IO_UNLOCK_SINGLE;
pub type FAST_IO_UNLOCK_ALL = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ProcessId: PEPROCESS,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_ALL = FAST_IO_UNLOCK_ALL;
pub type FAST_IO_UNLOCK_ALL_BY_KEY = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ProcessId: PVOID,
        Key: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_UNLOCK_ALL_BY_KEY = FAST_IO_UNLOCK_ALL_BY_KEY;
pub type FAST_IO_DEVICE_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        IoControlCode: ULONG,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_DEVICE_CONTROL = FAST_IO_DEVICE_CONTROL;
pub type FAST_IO_ACQUIRE_FILE = ::core::option::Option<
    unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT),
>;
pub type PFAST_IO_ACQUIRE_FILE = FAST_IO_ACQUIRE_FILE;
pub type FAST_IO_RELEASE_FILE = ::core::option::Option<
    unsafe extern "C" fn(FileObject: *mut _FILE_OBJECT),
>;
pub type PFAST_IO_RELEASE_FILE = FAST_IO_RELEASE_FILE;
pub type FAST_IO_DETACH_DEVICE = ::core::option::Option<
    unsafe extern "C" fn(
        SourceDevice: *mut _DEVICE_OBJECT,
        TargetDevice: *mut _DEVICE_OBJECT,
    ),
>;
pub type PFAST_IO_DETACH_DEVICE = FAST_IO_DETACH_DEVICE;
pub type FAST_IO_QUERY_NETWORK_OPEN_INFO = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        Wait: BOOLEAN,
        Buffer: *mut _FILE_NETWORK_OPEN_INFORMATION,
        IoStatus: *mut _IO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_NETWORK_OPEN_INFO = FAST_IO_QUERY_NETWORK_OPEN_INFO;
pub type FAST_IO_MDL_READ = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ = FAST_IO_MDL_READ;
pub type FAST_IO_MDL_READ_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ_COMPLETE = FAST_IO_MDL_READ_COMPLETE;
pub type FAST_IO_PREPARE_MDL_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_PREPARE_MDL_WRITE = FAST_IO_PREPARE_MDL_WRITE;
pub type FAST_IO_MDL_WRITE_COMPLETE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_WRITE_COMPLETE = FAST_IO_MDL_WRITE_COMPLETE;
pub type FAST_IO_ACQUIRE_FOR_MOD_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        EndingOffset: PLARGE_INTEGER,
        ResourceToRelease: *mut *mut _ERESOURCE,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_ACQUIRE_FOR_MOD_WRITE = FAST_IO_ACQUIRE_FOR_MOD_WRITE;
pub type FAST_IO_RELEASE_FOR_MOD_WRITE = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        ResourceToRelease: *mut _ERESOURCE,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_RELEASE_FOR_MOD_WRITE = FAST_IO_RELEASE_FOR_MOD_WRITE;
pub type FAST_IO_ACQUIRE_FOR_CCFLUSH = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_ACQUIRE_FOR_CCFLUSH = FAST_IO_ACQUIRE_FOR_CCFLUSH;
pub type FAST_IO_RELEASE_FOR_CCFLUSH = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> NTSTATUS,
>;
pub type PFAST_IO_RELEASE_FOR_CCFLUSH = FAST_IO_RELEASE_FOR_CCFLUSH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPRESSED_DATA_INFO {
    _unused: [u8; 0],
}
pub type FAST_IO_READ_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        Buffer: PVOID,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        CompressedDataInfo: *mut _COMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_READ_COMPRESSED = FAST_IO_READ_COMPRESSED;
pub type FAST_IO_WRITE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        Buffer: PVOID,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
        CompressedDataInfo: *mut _COMPRESSED_DATA_INFO,
        CompressedDataInfoLength: ULONG,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_WRITE_COMPRESSED = FAST_IO_WRITE_COMPRESSED;
pub type FAST_IO_MDL_READ_COMPLETE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_READ_COMPLETE_COMPRESSED = FAST_IO_MDL_READ_COMPLETE_COMPRESSED;
pub type FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = ::core::option::Option<
    unsafe extern "C" fn(
        FileObject: *mut _FILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED = FAST_IO_MDL_WRITE_COMPLETE_COMPRESSED;
pub type FAST_IO_QUERY_OPEN = ::core::option::Option<
    unsafe extern "C" fn(
        Irp: *mut _IRP,
        NetworkInformation: PFILE_NETWORK_OPEN_INFORMATION,
        DeviceObject: *mut _DEVICE_OBJECT,
    ) -> BOOLEAN,
>;
pub type PFAST_IO_QUERY_OPEN = FAST_IO_QUERY_OPEN;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FAST_IO_DISPATCH {
    pub SizeOfFastIoDispatch: ULONG,
    pub FastIoCheckIfPossible: PFAST_IO_CHECK_IF_POSSIBLE,
    pub FastIoRead: PFAST_IO_READ,
    pub FastIoWrite: PFAST_IO_WRITE,
    pub FastIoQueryBasicInfo: PFAST_IO_QUERY_BASIC_INFO,
    pub FastIoQueryStandardInfo: PFAST_IO_QUERY_STANDARD_INFO,
    pub FastIoLock: PFAST_IO_LOCK,
    pub FastIoUnlockSingle: PFAST_IO_UNLOCK_SINGLE,
    pub FastIoUnlockAll: PFAST_IO_UNLOCK_ALL,
    pub FastIoUnlockAllByKey: PFAST_IO_UNLOCK_ALL_BY_KEY,
    pub FastIoDeviceControl: PFAST_IO_DEVICE_CONTROL,
    pub AcquireFileForNtCreateSection: PFAST_IO_ACQUIRE_FILE,
    pub ReleaseFileForNtCreateSection: PFAST_IO_RELEASE_FILE,
    pub FastIoDetachDevice: PFAST_IO_DETACH_DEVICE,
    pub FastIoQueryNetworkOpenInfo: PFAST_IO_QUERY_NETWORK_OPEN_INFO,
    pub AcquireForModWrite: PFAST_IO_ACQUIRE_FOR_MOD_WRITE,
    pub MdlRead: PFAST_IO_MDL_READ,
    pub MdlReadComplete: PFAST_IO_MDL_READ_COMPLETE,
    pub PrepareMdlWrite: PFAST_IO_PREPARE_MDL_WRITE,
    pub MdlWriteComplete: PFAST_IO_MDL_WRITE_COMPLETE,
    pub FastIoReadCompressed: PFAST_IO_READ_COMPRESSED,
    pub FastIoWriteCompressed: PFAST_IO_WRITE_COMPRESSED,
    pub MdlReadCompleteCompressed: PFAST_IO_MDL_READ_COMPLETE_COMPRESSED,
    pub MdlWriteCompleteCompressed: PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED,
    pub FastIoQueryOpen: PFAST_IO_QUERY_OPEN,
    pub ReleaseForModWrite: PFAST_IO_RELEASE_FOR_MOD_WRITE,
    pub AcquireForCcFlush: PFAST_IO_ACQUIRE_FOR_CCFLUSH,
    pub ReleaseForCcFlush: PFAST_IO_RELEASE_FOR_CCFLUSH,
}
#[test]
fn bindgen_test_layout__FAST_IO_DISPATCH() {
    const UNINIT: ::core::mem::MaybeUninit<_FAST_IO_DISPATCH> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FAST_IO_DISPATCH>(),
        224usize,
        concat!("Size of: ", stringify!(_FAST_IO_DISPATCH)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FAST_IO_DISPATCH>(),
        8usize,
        concat!("Alignment of ", stringify!(_FAST_IO_DISPATCH)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SizeOfFastIoDispatch) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(SizeOfFastIoDispatch),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoCheckIfPossible) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoCheckIfPossible),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FastIoRead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoRead),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FastIoWrite) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoWrite),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoQueryBasicInfo) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoQueryBasicInfo),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoQueryStandardInfo) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoQueryStandardInfo),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FastIoLock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoLock),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoUnlockSingle) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoUnlockSingle),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FastIoUnlockAll) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoUnlockAll),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoUnlockAllByKey) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoUnlockAllByKey),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoDeviceControl) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoDeviceControl),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AcquireFileForNtCreateSection) as usize
                - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(AcquireFileForNtCreateSection),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ReleaseFileForNtCreateSection) as usize
                - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(ReleaseFileForNtCreateSection),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoDetachDevice) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoDetachDevice),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoQueryNetworkOpenInfo) as usize
                - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoQueryNetworkOpenInfo),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AcquireForModWrite) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(AcquireForModWrite),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlRead) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(MdlRead),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlReadComplete) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(MdlReadComplete),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrepareMdlWrite) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(PrepareMdlWrite),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).MdlWriteComplete) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(MdlWriteComplete),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoReadCompressed) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoReadCompressed),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoWriteCompressed) as usize - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoWriteCompressed),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).MdlReadCompleteCompressed) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(MdlReadCompleteCompressed),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).MdlWriteCompleteCompressed) as usize
                - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(MdlWriteCompleteCompressed),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FastIoQueryOpen) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(FastIoQueryOpen),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ReleaseForModWrite) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(ReleaseForModWrite),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AcquireForCcFlush) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(AcquireForCcFlush),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ReleaseForCcFlush) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_FAST_IO_DISPATCH),
            "::",
            stringify!(ReleaseForCcFlush),
        ),
    );
}
pub type PFAST_IO_DISPATCH = *mut _FAST_IO_DISPATCH;
pub mod _IO_ALLOCATION_ACTION {
    pub type Type = ::core::ffi::c_int;
    pub const KeepObject: Type = 1;
    pub const DeallocateObject: Type = 2;
    pub const DeallocateObjectKeepRegisters: Type = 3;
}
pub use self::_IO_ALLOCATION_ACTION::Type as IO_ALLOCATION_ACTION;
pub type DRIVER_CONTROL = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: *mut _DEVICE_OBJECT,
        Irp: *mut _IRP,
        MapRegisterBase: PVOID,
        Context: PVOID,
    ) -> IO_ALLOCATION_ACTION,
>;
pub type PDRIVER_CONTROL = DRIVER_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_SECURITY_CONTEXT {
    pub SecurityQos: PSECURITY_QUALITY_OF_SERVICE,
    pub AccessState: PACCESS_STATE,
    pub DesiredAccess: ACCESS_MASK,
    pub FullCreateOptions: ULONG,
}
#[test]
fn bindgen_test_layout__IO_SECURITY_CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_SECURITY_CONTEXT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_SECURITY_CONTEXT>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_SECURITY_CONTEXT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_SECURITY_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_SECURITY_CONTEXT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SecurityQos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_SECURITY_CONTEXT),
            "::",
            stringify!(SecurityQos),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AccessState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_SECURITY_CONTEXT),
            "::",
            stringify!(AccessState),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DesiredAccess) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_SECURITY_CONTEXT),
            "::",
            stringify!(DesiredAccess),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FullCreateOptions) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_SECURITY_CONTEXT),
            "::",
            stringify!(FullCreateOptions),
        ),
    );
}
impl Default for _IO_SECURITY_CONTEXT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PIO_SECURITY_CONTEXT = *mut _IO_SECURITY_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VPB {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub Flags: USHORT,
    pub VolumeLabelLength: USHORT,
    pub DeviceObject: *mut _DEVICE_OBJECT,
    pub RealDevice: *mut _DEVICE_OBJECT,
    pub SerialNumber: ULONG,
    pub ReferenceCount: ULONG,
    pub VolumeLabel: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout__VPB() {
    const UNINIT: ::core::mem::MaybeUninit<_VPB> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_VPB>(),
        96usize,
        concat!("Size of: ", stringify!(_VPB)),
    );
    assert_eq!(
        ::core::mem::align_of::<_VPB>(),
        8usize,
        concat!("Alignment of ", stringify!(_VPB)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(Type)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(Size)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(Flags)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_VPB),
            "::",
            stringify!(VolumeLabelLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(DeviceObject)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RealDevice) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(RealDevice)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SerialNumber) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(SerialNumber)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReferenceCount) as usize - ptr as usize },
        28usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(ReferenceCount)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_VPB), "::", stringify!(VolumeLabel)),
    );
}
impl Default for _VPB {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK {
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1,
    pub DeviceRoutine: PDRIVER_CONTROL,
    pub DeviceContext: PVOID,
    pub NumberOfMapRegisters: ULONG,
    pub DeviceObject: PVOID,
    pub CurrentIrp: PVOID,
    pub BufferChainingDpc: PKDPC,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WAIT_CONTEXT_BLOCK__bindgen_ty_1 {
    pub WaitQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    pub DmaWaitEntry: LIST_ENTRY,
    pub NumberOfChannels: ULONG,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DmaWaitEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DmaWaitEntry),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NumberOfChannels) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(NumberOfChannels),
        ),
    );
}
impl Default for _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _WAIT_CONTEXT_BLOCK__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncCallback(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SyncCallback(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DmaContext(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DmaContext(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ZeroMapRegisters(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ZeroMapRegisters(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn NumberOfRemapPages(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_NumberOfRemapPages(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncCallback: ULONG,
        DmaContext: ULONG,
        ZeroMapRegisters: ULONG,
        Reserved: ULONG,
        NumberOfRemapPages: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                1u8,
                {
                    let SyncCallback: u32 = unsafe {
                        ::core::mem::transmute(SyncCallback)
                    };
                    SyncCallback as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                1usize,
                1u8,
                {
                    let DmaContext: u32 = unsafe { ::core::mem::transmute(DmaContext) };
                    DmaContext as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                2usize,
                1u8,
                {
                    let ZeroMapRegisters: u32 = unsafe {
                        ::core::mem::transmute(ZeroMapRegisters)
                    };
                    ZeroMapRegisters as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                3usize,
                9u8,
                {
                    let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
                    Reserved as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                12usize,
                20u8,
                {
                    let NumberOfRemapPages: u32 = unsafe {
                        ::core::mem::transmute(NumberOfRemapPages)
                    };
                    NumberOfRemapPages as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__WAIT_CONTEXT_BLOCK__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_WAIT_CONTEXT_BLOCK__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_WAIT_CONTEXT_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitQueueEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK__bindgen_ty_1),
            "::",
            stringify!(WaitQueueEntry),
        ),
    );
}
impl Default for _WAIT_CONTEXT_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__WAIT_CONTEXT_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_WAIT_CONTEXT_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_WAIT_CONTEXT_BLOCK>(),
        72usize,
        concat!("Size of: ", stringify!(_WAIT_CONTEXT_BLOCK)),
    );
    assert_eq!(
        ::core::mem::align_of::<_WAIT_CONTEXT_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_WAIT_CONTEXT_BLOCK)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceRoutine) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(DeviceRoutine),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceContext) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(DeviceContext),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NumberOfMapRegisters) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(NumberOfMapRegisters),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(DeviceObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentIrp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(CurrentIrp),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).BufferChainingDpc) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_WAIT_CONTEXT_BLOCK),
            "::",
            stringify!(BufferChainingDpc),
        ),
    );
}
impl Default for _WAIT_CONTEXT_BLOCK {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type WAIT_CONTEXT_BLOCK = _WAIT_CONTEXT_BLOCK;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _DEVICE_OBJECT {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub ReferenceCount: LONG,
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub NextDevice: *mut _DEVICE_OBJECT,
    pub AttachedDevice: *mut _DEVICE_OBJECT,
    pub CurrentIrp: *mut _IRP,
    pub Timer: PIO_TIMER,
    pub Flags: ULONG,
    pub Characteristics: ULONG,
    pub Vpb: PVPB,
    pub DeviceExtension: PVOID,
    pub DeviceType: ULONG,
    pub StackSize: CCHAR,
    pub Queue: _DEVICE_OBJECT__bindgen_ty_1,
    pub AlignmentRequirement: ULONG,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub Dpc: KDPC,
    pub ActiveThreadCount: ULONG,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
    pub DeviceLock: KEVENT,
    pub SectorSize: USHORT,
    pub Spare1: USHORT,
    pub DeviceObjectExtension: *mut _DEVOBJ_EXTENSION,
    pub Reserved: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _DEVICE_OBJECT__bindgen_ty_1 {
    pub ListEntry: LIST_ENTRY,
    pub Wcb: WAIT_CONTEXT_BLOCK,
}
#[test]
fn bindgen_test_layout__DEVICE_OBJECT__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_DEVICE_OBJECT__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DEVICE_OBJECT__bindgen_ty_1>(),
        72usize,
        concat!("Size of: ", stringify!(_DEVICE_OBJECT__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVICE_OBJECT__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_DEVICE_OBJECT__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT__bindgen_ty_1),
            "::",
            stringify!(ListEntry),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Wcb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT__bindgen_ty_1),
            "::",
            stringify!(Wcb),
        ),
    );
}
impl Default for _DEVICE_OBJECT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__DEVICE_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_DEVICE_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DEVICE_OBJECT>(),
        336usize,
        concat!("Size of: ", stringify!(_DEVICE_OBJECT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVICE_OBJECT>(),
        16usize,
        concat!("Alignment of ", stringify!(_DEVICE_OBJECT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Type)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Size)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReferenceCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(ReferenceCount),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverObject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DriverObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextDevice) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(NextDevice),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AttachedDevice) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(AttachedDevice),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentIrp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(CurrentIrp),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timer) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Timer)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Flags)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Characteristics),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vpb) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Vpb)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceExtension) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceExtension),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackSize) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StackSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Queue) as usize - ptr as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Queue)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AlignmentRequirement) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(AlignmentRequirement),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceQueue) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceQueue),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Dpc) as usize - ptr as usize },
        200usize,
        concat!("Offset of field: ", stringify!(_DEVICE_OBJECT), "::", stringify!(Dpc)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ActiveThreadCount) as usize - ptr as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(ActiveThreadCount),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(SecurityDescriptor),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceLock) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceLock),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorSize) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(SectorSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Spare1) as usize - ptr as usize },
        306usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Spare1),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DeviceObjectExtension) as usize - ptr as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceObjectExtension),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Reserved),
        ),
    );
}
impl Default for _DEVICE_OBJECT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT_POWER_EXTENSION {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVOBJ_EXTENSION {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub PowerFlags: ULONG,
    pub Dope: *mut _DEVICE_OBJECT_POWER_EXTENSION,
    pub ExtensionFlags: ULONG,
    pub DeviceNode: PVOID,
    pub AttachedTo: PDEVICE_OBJECT,
    pub StartIoCount: LONG,
    pub StartIoKey: LONG,
    pub StartIoFlags: ULONG,
    pub Vpb: PVPB,
    pub DependencyNode: PVOID,
    pub InterruptContext: PVOID,
    pub InterruptCount: LONG,
    pub VerifierContext: PVOID,
}
#[test]
fn bindgen_test_layout__DEVOBJ_EXTENSION() {
    const UNINIT: ::core::mem::MaybeUninit<_DEVOBJ_EXTENSION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DEVOBJ_EXTENSION>(),
        112usize,
        concat!("Size of: ", stringify!(_DEVOBJ_EXTENSION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVOBJ_EXTENSION>(),
        8usize,
        concat!("Alignment of ", stringify!(_DEVOBJ_EXTENSION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(Type),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(DeviceObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PowerFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(PowerFlags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Dope) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(Dope),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExtensionFlags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(ExtensionFlags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceNode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(DeviceNode),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AttachedTo) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(AttachedTo),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartIoCount) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(StartIoCount),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartIoKey) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(StartIoKey),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartIoFlags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(StartIoFlags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vpb) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(Vpb),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DependencyNode) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(DependencyNode),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InterruptContext) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(InterruptContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterruptCount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(InterruptCount),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VerifierContext) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVOBJ_EXTENSION),
            "::",
            stringify!(VerifierContext),
        ),
    );
}
impl Default for _DEVOBJ_EXTENSION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_EXTENSION {
    pub DriverObject: *mut _DRIVER_OBJECT,
    pub AddDevice: PDRIVER_ADD_DEVICE,
    pub Count: ULONG,
    pub ServiceKeyName: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__DRIVER_EXTENSION() {
    const UNINIT: ::core::mem::MaybeUninit<_DRIVER_EXTENSION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DRIVER_EXTENSION>(),
        40usize,
        concat!("Size of: ", stringify!(_DRIVER_EXTENSION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DRIVER_EXTENSION>(),
        8usize,
        concat!("Alignment of ", stringify!(_DRIVER_EXTENSION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverObject) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_EXTENSION),
            "::",
            stringify!(DriverObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddDevice) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_EXTENSION),
            "::",
            stringify!(AddDevice),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_EXTENSION),
            "::",
            stringify!(Count),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ServiceKeyName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_EXTENSION),
            "::",
            stringify!(ServiceKeyName),
        ),
    );
}
impl Default for _DRIVER_EXTENSION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PDRIVER_EXTENSION = *mut _DRIVER_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DRIVER_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Flags: ULONG,
    pub DriverStart: PVOID,
    pub DriverSize: ULONG,
    pub DriverSection: PVOID,
    pub DriverExtension: PDRIVER_EXTENSION,
    pub DriverName: UNICODE_STRING,
    pub HardwareDatabase: PUNICODE_STRING,
    pub FastIoDispatch: PFAST_IO_DISPATCH,
    pub DriverInit: PDRIVER_INITIALIZE,
    pub DriverStartIo: PDRIVER_STARTIO,
    pub DriverUnload: PDRIVER_UNLOAD,
    pub MajorFunction: [PDRIVER_DISPATCH; 28usize],
}
#[test]
fn bindgen_test_layout__DRIVER_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_DRIVER_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DRIVER_OBJECT>(),
        336usize,
        concat!("Size of: ", stringify!(_DRIVER_OBJECT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DRIVER_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_DRIVER_OBJECT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_DRIVER_OBJECT), "::", stringify!(Type)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_DRIVER_OBJECT), "::", stringify!(Size)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DeviceObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_DRIVER_OBJECT), "::", stringify!(Flags)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverStart) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverStart),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverSection) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverSection),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverExtension) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverExtension),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverName) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverName),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).HardwareDatabase) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(HardwareDatabase),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FastIoDispatch) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(FastIoDispatch),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverInit) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverInit),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverStartIo) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverStartIo),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverUnload) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverUnload),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorFunction) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(MajorFunction),
        ),
    );
}
impl Default for _DRIVER_OBJECT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PDRIVER_OBJECT = *mut _DRIVER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECTION_OBJECT_POINTERS {
    pub DataSectionObject: PVOID,
    pub SharedCacheMap: PVOID,
    pub ImageSectionObject: PVOID,
}
#[test]
fn bindgen_test_layout__SECTION_OBJECT_POINTERS() {
    const UNINIT: ::core::mem::MaybeUninit<_SECTION_OBJECT_POINTERS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SECTION_OBJECT_POINTERS>(),
        24usize,
        concat!("Size of: ", stringify!(_SECTION_OBJECT_POINTERS)),
    );
    assert_eq!(
        ::core::mem::align_of::<_SECTION_OBJECT_POINTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_SECTION_OBJECT_POINTERS)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DataSectionObject) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECTION_OBJECT_POINTERS),
            "::",
            stringify!(DataSectionObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedCacheMap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECTION_OBJECT_POINTERS),
            "::",
            stringify!(SharedCacheMap),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ImageSectionObject) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECTION_OBJECT_POINTERS),
            "::",
            stringify!(ImageSectionObject),
        ),
    );
}
impl Default for _SECTION_OBJECT_POINTERS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SECTION_OBJECT_POINTERS = _SECTION_OBJECT_POINTERS;
pub type PSECTION_OBJECT_POINTERS = *mut SECTION_OBJECT_POINTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_CONTEXT {
    pub Port: PVOID,
    pub Key: PVOID,
    pub UsageCount: LONG_PTR,
}
#[test]
fn bindgen_test_layout__IO_COMPLETION_CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_COMPLETION_CONTEXT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_COMPLETION_CONTEXT>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_COMPLETION_CONTEXT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_COMPLETION_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_COMPLETION_CONTEXT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(Port),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(Key),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UsageCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(UsageCount),
        ),
    );
}
impl Default for _IO_COMPLETION_CONTEXT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PIO_COMPLETION_CONTEXT = *mut _IO_COMPLETION_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECT {
    pub Type: CSHORT,
    pub Size: CSHORT,
    pub DeviceObject: PDEVICE_OBJECT,
    pub Vpb: PVPB,
    pub FsContext: PVOID,
    pub FsContext2: PVOID,
    pub SectionObjectPointer: PSECTION_OBJECT_POINTERS,
    pub PrivateCacheMap: PVOID,
    pub FinalStatus: NTSTATUS,
    pub RelatedFileObject: *mut _FILE_OBJECT,
    pub LockOperation: BOOLEAN,
    pub DeletePending: BOOLEAN,
    pub ReadAccess: BOOLEAN,
    pub WriteAccess: BOOLEAN,
    pub DeleteAccess: BOOLEAN,
    pub SharedRead: BOOLEAN,
    pub SharedWrite: BOOLEAN,
    pub SharedDelete: BOOLEAN,
    pub Flags: ULONG,
    pub FileName: UNICODE_STRING,
    pub CurrentByteOffset: LARGE_INTEGER,
    pub Waiters: ULONG,
    pub Busy: ULONG,
    pub LastLock: PVOID,
    pub Lock: KEVENT,
    pub Event: KEVENT,
    pub CompletionContext: PIO_COMPLETION_CONTEXT,
    pub IrpListLock: KSPIN_LOCK,
    pub IrpList: LIST_ENTRY,
    pub FileObjectExtension: PVOID,
}
#[test]
fn bindgen_test_layout__FILE_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECT>(),
        216usize,
        concat!("Size of: ", stringify!(_FILE_OBJECT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_OBJECT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Type)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Size)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(DeviceObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vpb) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Vpb)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsContext) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FsContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsContext2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FsContext2),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SectionObjectPointer) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(SectionObjectPointer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrivateCacheMap) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(PrivateCacheMap),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinalStatus) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FinalStatus),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).RelatedFileObject) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(RelatedFileObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockOperation) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(LockOperation),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeletePending) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(DeletePending),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadAccess) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(ReadAccess),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WriteAccess) as usize - ptr as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(WriteAccess),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeleteAccess) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(DeleteAccess),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedRead) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(SharedRead),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedWrite) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(SharedWrite),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedDelete) as usize - ptr as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(SharedDelete),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Flags)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FileName),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CurrentByteOffset) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(CurrentByteOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Waiters) as usize - ptr as usize },
        112usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Waiters)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Busy) as usize - ptr as usize },
        116usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Busy)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastLock) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(LastLock),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        128usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Lock)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Event) as usize - ptr as usize },
        152usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(Event)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CompletionContext) as usize - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(CompletionContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IrpListLock) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(IrpListLock),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IrpList) as usize - ptr as usize },
        192usize,
        concat!("Offset of field: ", stringify!(_FILE_OBJECT), "::", stringify!(IrpList)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileObjectExtension) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FileObjectExtension),
        ),
    );
}
impl Default for _FILE_OBJECT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _IRP {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub MdlAddress: PMDL,
    pub Flags: ULONG,
    pub AssociatedIrp: _IRP__bindgen_ty_1,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub RequestorMode: KPROCESSOR_MODE,
    pub PendingReturned: BOOLEAN,
    pub StackCount: CHAR,
    pub CurrentLocation: CHAR,
    pub Cancel: BOOLEAN,
    pub CancelIrql: KIRQL,
    pub ApcEnvironment: CCHAR,
    pub AllocationFlags: UCHAR,
    pub __bindgen_anon_1: _IRP__bindgen_ty_2,
    pub UserEvent: PKEVENT,
    pub Overlay: _IRP__bindgen_ty_3,
    pub CancelRoutine: PDRIVER_CANCEL,
    pub UserBuffer: PVOID,
    pub Tail: _IRP__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_1 {
    pub MasterIrp: *mut _IRP,
    pub IrpCount: LONG,
    pub SystemBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MasterIrp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(MasterIrp),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IrpCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(IrpCount),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(SystemBuffer),
        ),
    );
}
impl Default for _IRP__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2 {
    pub UserIosb: PIO_STATUS_BLOCK,
    pub IoRingContext: PVOID,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_2)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserIosb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(UserIosb),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoRingContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(IoRingContext),
        ),
    );
}
impl Default for _IRP__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3 {
    pub AsynchronousParameters: _IRP__bindgen_ty_3__bindgen_ty_1,
    pub AllocationSize: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: PIO_APC_ROUTINE,
    pub IssuingProcess: PVOID,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserApcRoutine),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IssuingProcess) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(IssuingProcess),
        ),
    );
}
impl Default for _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    pub UserApcContext: PVOID,
    pub IoRing: *mut _IORING_OBJECT,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(UserApcContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoRing) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(IoRing),
        ),
    );
}
impl Default for _IRP__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_3__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_3__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_3__bindgen_ty_1)),
    );
}
impl Default for _IRP__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_3> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_3)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_3)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AsynchronousParameters) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3),
            "::",
            stringify!(AsynchronousParameters),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_3),
            "::",
            stringify!(AllocationSize),
        ),
    );
}
impl Default for _IRP__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4 {
    pub Overlay: _IRP__bindgen_ty_4__bindgen_ty_1,
    pub Apc: KAPC,
    pub CompletionKey: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub Thread: PETHREAD,
    pub AuxiliaryBuffer: PCHAR,
    pub __bindgen_anon_2: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    pub OriginalFileObject: PFILE_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub DeviceQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub DriverContext: [PVOID; 4usize],
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DriverContext),
        ),
    );
}
impl Default for _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DeviceQueueEntry) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DeviceQueueEntry),
        ),
    );
}
impl Default for _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub ListEntry: LIST_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub CurrentStackLocation: *mut _IO_STACK_LOCATION,
    pub PacketType: ULONG,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CurrentStackLocation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(CurrentStackLocation),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PacketType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(PacketType),
        ),
    );
}
impl Default for _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ListEntry),
        ),
    );
}
impl Default for _IRP__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_4__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_4__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_4__bindgen_ty_1>(),
        80usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_4__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_4__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(Thread),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AuxiliaryBuffer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(AuxiliaryBuffer),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OriginalFileObject) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(OriginalFileObject),
        ),
    );
}
impl Default for _IRP__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_4> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_4>(),
        88usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_4)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_4)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Overlay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4),
            "::",
            stringify!(Overlay),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Apc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4),
            "::",
            stringify!(Apc),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_4),
            "::",
            stringify!(CompletionKey),
        ),
    );
}
impl Default for _IRP__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IRP() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP>(),
        208usize,
        concat!("Size of: ", stringify!(_IRP)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP>(),
        16usize,
        concat!("Alignment of ", stringify!(_IRP)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Type)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Size)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(MdlAddress)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Flags)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AssociatedIrp) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(AssociatedIrp)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListEntry) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(ThreadListEntry)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoStatus) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(IoStatus)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RequestorMode) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(RequestorMode)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PendingReturned) as usize - ptr as usize },
        65usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(PendingReturned)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackCount) as usize - ptr as usize },
        66usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(StackCount)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentLocation) as usize - ptr as usize },
        67usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(CurrentLocation)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cancel) as usize - ptr as usize },
        68usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Cancel)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CancelIrql) as usize - ptr as usize },
        69usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(CancelIrql)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcEnvironment) as usize - ptr as usize },
        70usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(ApcEnvironment)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationFlags) as usize - ptr as usize },
        71usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(AllocationFlags)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserEvent) as usize - ptr as usize },
        80usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(UserEvent)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Overlay) as usize - ptr as usize },
        88usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Overlay)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CancelRoutine) as usize - ptr as usize },
        104usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(CancelRoutine)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserBuffer) as usize - ptr as usize },
        112usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(UserBuffer)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Tail) as usize - ptr as usize },
        120usize,
        concat!("Offset of field: ", stringify!(_IRP), "::", stringify!(Tail)),
    );
}
impl Default for _IRP {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IRP = _IRP;
pub type PIRP = *mut IRP;
pub type IO_COMPLETION_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        DeviceObject: PDEVICE_OBJECT,
        Irp: PIRP,
        Context: PVOID,
    ) -> NTSTATUS,
>;
pub type PIO_COMPLETION_ROUTINE = IO_COMPLETION_ROUTINE;
pub mod _DEVICE_RELATION_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const BusRelations: Type = 0;
    pub const EjectionRelations: Type = 1;
    pub const PowerRelations: Type = 2;
    pub const RemovalRelations: Type = 3;
    pub const TargetDeviceRelation: Type = 4;
    pub const SingleBusRelations: Type = 5;
    pub const TransportRelations: Type = 6;
}
pub use self::_DEVICE_RELATION_TYPE::Type as DEVICE_RELATION_TYPE;
pub mod _DEVICE_USAGE_NOTIFICATION_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const DeviceUsageTypeUndefined: Type = 0;
    pub const DeviceUsageTypePaging: Type = 1;
    pub const DeviceUsageTypeHibernation: Type = 2;
    pub const DeviceUsageTypeDumpFile: Type = 3;
    pub const DeviceUsageTypeBoot: Type = 4;
    pub const DeviceUsageTypePostDisplay: Type = 5;
    pub const DeviceUsageTypeGuestAssigned: Type = 6;
}
pub use self::_DEVICE_USAGE_NOTIFICATION_TYPE::Type as DEVICE_USAGE_NOTIFICATION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INTERFACE {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Context: PVOID,
    pub InterfaceReference: PINTERFACE_REFERENCE,
    pub InterfaceDereference: PINTERFACE_DEREFERENCE,
}
#[test]
fn bindgen_test_layout__INTERFACE() {
    const UNINIT: ::core::mem::MaybeUninit<_INTERFACE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_INTERFACE>(),
        32usize,
        concat!("Size of: ", stringify!(_INTERFACE)),
    );
    assert_eq!(
        ::core::mem::align_of::<_INTERFACE>(),
        8usize,
        concat!("Alignment of ", stringify!(_INTERFACE)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_INTERFACE), "::", stringify!(Size)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(_INTERFACE), "::", stringify!(Version)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Context) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_INTERFACE), "::", stringify!(Context)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InterfaceReference) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_INTERFACE),
            "::",
            stringify!(InterfaceReference),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InterfaceDereference) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_INTERFACE),
            "::",
            stringify!(InterfaceDereference),
        ),
    );
}
impl Default for _INTERFACE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PINTERFACE = *mut _INTERFACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_CAPABILITIES {
    pub Size: USHORT,
    pub Version: USHORT,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub Address: ULONG,
    pub UINumber: ULONG,
    pub DeviceState: [DEVICE_POWER_STATE; 7usize],
    pub SystemWake: SYSTEM_POWER_STATE,
    pub DeviceWake: DEVICE_POWER_STATE,
    pub D1Latency: ULONG,
    pub D2Latency: ULONG,
    pub D3Latency: ULONG,
}
#[test]
fn bindgen_test_layout__DEVICE_CAPABILITIES() {
    const UNINIT: ::core::mem::MaybeUninit<_DEVICE_CAPABILITIES> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DEVICE_CAPABILITIES>(),
        64usize,
        concat!("Size of: ", stringify!(_DEVICE_CAPABILITIES)),
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVICE_CAPABILITIES>(),
        4usize,
        concat!("Alignment of ", stringify!(_DEVICE_CAPABILITIES)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(Version),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(Address),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UINumber) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(UINumber),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(DeviceState),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemWake) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(SystemWake),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceWake) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(DeviceWake),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).D1Latency) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(D1Latency),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).D2Latency) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(D2Latency),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).D3Latency) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_CAPABILITIES),
            "::",
            stringify!(D3Latency),
        ),
    );
}
impl Default for _DEVICE_CAPABILITIES {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _DEVICE_CAPABILITIES {
    #[inline]
    pub fn DeviceD1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceD2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LockSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LockSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EjectSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Removable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Removable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DockDevice(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DockDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UniqueID(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UniqueID(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SilentInstall(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SilentInstall(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RawDeviceOK(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RawDeviceOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SurpriseRemovalOK(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SurpriseRemovalOK(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD0(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD0(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD2(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD2(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromD3(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromD3(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardwareDisabled(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardwareDisabled(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NonDynamic(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NonDynamic(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WarmEjectSupported(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WarmEjectSupported(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoDisplayInUI(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoDisplayInUI(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WakeFromInterrupt(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WakeFromInterrupt(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecureDevice(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecureDevice(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ChildOfVgaEnabledBridge(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ChildOfVgaEnabledBridge(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DecodeIoOnBoot(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DecodeIoOnBoot(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeviceD1: ULONG,
        DeviceD2: ULONG,
        LockSupported: ULONG,
        EjectSupported: ULONG,
        Removable: ULONG,
        DockDevice: ULONG,
        UniqueID: ULONG,
        SilentInstall: ULONG,
        RawDeviceOK: ULONG,
        SurpriseRemovalOK: ULONG,
        WakeFromD0: ULONG,
        WakeFromD1: ULONG,
        WakeFromD2: ULONG,
        WakeFromD3: ULONG,
        HardwareDisabled: ULONG,
        NonDynamic: ULONG,
        WarmEjectSupported: ULONG,
        NoDisplayInUI: ULONG,
        Reserved1: ULONG,
        WakeFromInterrupt: ULONG,
        SecureDevice: ULONG,
        ChildOfVgaEnabledBridge: ULONG,
        DecodeIoOnBoot: ULONG,
        Reserved: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                1u8,
                {
                    let DeviceD1: u32 = unsafe { ::core::mem::transmute(DeviceD1) };
                    DeviceD1 as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                1usize,
                1u8,
                {
                    let DeviceD2: u32 = unsafe { ::core::mem::transmute(DeviceD2) };
                    DeviceD2 as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                2usize,
                1u8,
                {
                    let LockSupported: u32 = unsafe {
                        ::core::mem::transmute(LockSupported)
                    };
                    LockSupported as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                3usize,
                1u8,
                {
                    let EjectSupported: u32 = unsafe {
                        ::core::mem::transmute(EjectSupported)
                    };
                    EjectSupported as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                1u8,
                {
                    let Removable: u32 = unsafe { ::core::mem::transmute(Removable) };
                    Removable as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                5usize,
                1u8,
                {
                    let DockDevice: u32 = unsafe { ::core::mem::transmute(DockDevice) };
                    DockDevice as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                6usize,
                1u8,
                {
                    let UniqueID: u32 = unsafe { ::core::mem::transmute(UniqueID) };
                    UniqueID as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                7usize,
                1u8,
                {
                    let SilentInstall: u32 = unsafe {
                        ::core::mem::transmute(SilentInstall)
                    };
                    SilentInstall as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                8usize,
                1u8,
                {
                    let RawDeviceOK: u32 = unsafe {
                        ::core::mem::transmute(RawDeviceOK)
                    };
                    RawDeviceOK as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                9usize,
                1u8,
                {
                    let SurpriseRemovalOK: u32 = unsafe {
                        ::core::mem::transmute(SurpriseRemovalOK)
                    };
                    SurpriseRemovalOK as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                10usize,
                1u8,
                {
                    let WakeFromD0: u32 = unsafe { ::core::mem::transmute(WakeFromD0) };
                    WakeFromD0 as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                11usize,
                1u8,
                {
                    let WakeFromD1: u32 = unsafe { ::core::mem::transmute(WakeFromD1) };
                    WakeFromD1 as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                12usize,
                1u8,
                {
                    let WakeFromD2: u32 = unsafe { ::core::mem::transmute(WakeFromD2) };
                    WakeFromD2 as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                13usize,
                1u8,
                {
                    let WakeFromD3: u32 = unsafe { ::core::mem::transmute(WakeFromD3) };
                    WakeFromD3 as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                14usize,
                1u8,
                {
                    let HardwareDisabled: u32 = unsafe {
                        ::core::mem::transmute(HardwareDisabled)
                    };
                    HardwareDisabled as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                15usize,
                1u8,
                {
                    let NonDynamic: u32 = unsafe { ::core::mem::transmute(NonDynamic) };
                    NonDynamic as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                16usize,
                1u8,
                {
                    let WarmEjectSupported: u32 = unsafe {
                        ::core::mem::transmute(WarmEjectSupported)
                    };
                    WarmEjectSupported as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                17usize,
                1u8,
                {
                    let NoDisplayInUI: u32 = unsafe {
                        ::core::mem::transmute(NoDisplayInUI)
                    };
                    NoDisplayInUI as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                18usize,
                1u8,
                {
                    let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
                    Reserved1 as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                19usize,
                1u8,
                {
                    let WakeFromInterrupt: u32 = unsafe {
                        ::core::mem::transmute(WakeFromInterrupt)
                    };
                    WakeFromInterrupt as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                20usize,
                1u8,
                {
                    let SecureDevice: u32 = unsafe {
                        ::core::mem::transmute(SecureDevice)
                    };
                    SecureDevice as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                21usize,
                1u8,
                {
                    let ChildOfVgaEnabledBridge: u32 = unsafe {
                        ::core::mem::transmute(ChildOfVgaEnabledBridge)
                    };
                    ChildOfVgaEnabledBridge as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                22usize,
                1u8,
                {
                    let DecodeIoOnBoot: u32 = unsafe {
                        ::core::mem::transmute(DecodeIoOnBoot)
                    };
                    DecodeIoOnBoot as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                23usize,
                9u8,
                {
                    let Reserved: u32 = unsafe { ::core::mem::transmute(Reserved) };
                    Reserved as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
pub type PDEVICE_CAPABILITIES = *mut _DEVICE_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _POWER_SEQUENCE {
    pub SequenceD1: ULONG,
    pub SequenceD2: ULONG,
    pub SequenceD3: ULONG,
}
#[test]
fn bindgen_test_layout__POWER_SEQUENCE() {
    const UNINIT: ::core::mem::MaybeUninit<_POWER_SEQUENCE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_POWER_SEQUENCE>(),
        12usize,
        concat!("Size of: ", stringify!(_POWER_SEQUENCE)),
    );
    assert_eq!(
        ::core::mem::align_of::<_POWER_SEQUENCE>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_SEQUENCE)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SequenceD1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SEQUENCE),
            "::",
            stringify!(SequenceD1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SequenceD2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SEQUENCE),
            "::",
            stringify!(SequenceD2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SequenceD3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SEQUENCE),
            "::",
            stringify!(SequenceD3),
        ),
    );
}
pub type PPOWER_SEQUENCE = *mut _POWER_SEQUENCE;
pub mod BUS_QUERY_ID_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const BusQueryDeviceID: Type = 0;
    pub const BusQueryHardwareIDs: Type = 1;
    pub const BusQueryCompatibleIDs: Type = 2;
    pub const BusQueryInstanceID: Type = 3;
    pub const BusQueryDeviceSerialNumber: Type = 4;
    pub const BusQueryContainerID: Type = 5;
}
pub mod DEVICE_TEXT_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const DeviceTextDescription: Type = 0;
    pub const DeviceTextLocationInformation: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION {
    pub MajorFunction: UCHAR,
    pub MinorFunction: UCHAR,
    pub Flags: UCHAR,
    pub Control: UCHAR,
    pub Parameters: _IO_STACK_LOCATION__bindgen_ty_1,
    pub DeviceObject: PDEVICE_OBJECT,
    pub FileObject: PFILE_OBJECT,
    pub CompletionRoutine: PIO_COMPLETION_ROUTINE,
    pub Context: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1 {
    pub Create: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1,
    pub CreatePipe: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2,
    pub CreateMailslot: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3,
    pub Read: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4,
    pub Write: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5,
    pub QueryDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6,
    pub NotifyDirectory: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7,
    pub NotifyDirectoryEx: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8,
    pub QueryFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9,
    pub SetFile: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10,
    pub QueryEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11,
    pub SetEa: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12,
    pub QueryVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13,
    pub SetVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14,
    pub FileSystemControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15,
    pub LockControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16,
    pub DeviceIoControl: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17,
    pub QuerySecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18,
    pub SetSecurity: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19,
    pub MountVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20,
    pub VerifyVolume: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21,
    pub Scsi: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22,
    pub QueryQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23,
    pub SetQuota: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24,
    pub QueryDeviceRelations: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25,
    pub QueryInterface: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26,
    pub DeviceCapabilities: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27,
    pub FilterResourceRequirements: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28,
    pub ReadWriteConfig: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29,
    pub SetLock: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30,
    pub QueryId: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31,
    pub QueryDeviceText: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32,
    pub UsageNotification: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33,
    pub WaitWake: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34,
    pub PowerSequence: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35,
    pub Power: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36,
    pub StartDevice: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37,
    pub WMI: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38,
    pub Others: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub FileAttributes: USHORT,
    pub ShareAccess: USHORT,
    pub __bindgen_padding_1: u32,
    pub EaLength: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SecurityContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SecurityContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Options) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Options),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(FileAttributes),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShareAccess) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ShareAccess),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaLength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(EaLength),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PNAMED_PIPE_CREATE_PARAMETERS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SecurityContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(SecurityContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Options) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Options),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Reserved),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShareAccess) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ShareAccess),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parameters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Parameters),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PMAILSLOT_CREATE_PARAMETERS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SecurityContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(SecurityContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Options) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Options),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Reserved),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShareAccess) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ShareAccess),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parameters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Parameters),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub Flags: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Key),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ByteOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(ByteOffset),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub Flags: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Key),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ByteOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(ByteOffset),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    pub Length: ULONG,
    pub FileName: PUNICODE_STRING,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub __bindgen_padding_0: u32,
    pub FileIndex: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(FileName),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileInformationClass) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(FileInformationClass),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(FileIndex),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CompletionFilter) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(CompletionFilter),
        ),
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
    pub __bindgen_padding_1: u32,
    pub DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CompletionFilter) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(CompletionFilter),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DirectoryNotifyInformationClass) as usize
                - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(DirectoryNotifyInformationClass),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileInformationClass) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(FileInformationClass),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub FileObject: PFILE_OBJECT,
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1,
    pub ClusterCount: ULONG,
    pub DeleteHandle: HANDLE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub AdvanceOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1,
        >(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(
                _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1
            ),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReplaceIfExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(ReplaceIfExists),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AdvanceOnly) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(
                _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(AdvanceOnly),
        ),
    );
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClusterCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1),
            "::",
            stringify!(ClusterCount),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeleteHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1),
            "::",
            stringify!(DeleteHandle),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileInformationClass) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(FileInformationClass),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileObject) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(FileObject),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    pub Length: ULONG,
    pub EaList: PVOID,
    pub EaListLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub EaIndex: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaList) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(EaList),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaListLength) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(EaListLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(EaIndex),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12 {
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Length),
        ),
    );
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FsInformationClass) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(FsInformationClass),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FsInformationClass) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(FsInformationClass),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub FsControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(FsControlCode),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).Type3InputBuffer) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(Type3InputBuffer),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_15 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    pub Length: PLARGE_INTEGER,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(Key),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ByteOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(ByteOffset),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_16 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub IoControlCode: ULONG,
    pub Type3InputBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(IoControlCode),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).Type3InputBuffer) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(Type3InputBuffer),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_17 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityInformation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(SecurityInformation),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(Length),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityInformation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(SecurityInformation),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(SecurityDescriptor),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_19 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
    pub OutputBufferLength: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vpb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20),
            "::",
            stringify!(Vpb),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20),
            "::",
            stringify!(DeviceObject),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_20 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vpb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21),
            "::",
            stringify!(Vpb),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21),
            "::",
            stringify!(DeviceObject),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_21 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    pub Srb: *mut _SCSI_REQUEST_BLOCK,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Srb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22),
            "::",
            stringify!(Srb),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_22 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    pub Length: ULONG,
    pub StartSid: PSID,
    pub SidList: PFILE_GET_QUOTA_INFORMATION,
    pub SidListLength: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartSid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23),
            "::",
            stringify!(StartSid),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SidList) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23),
            "::",
            stringify!(SidList),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SidListLength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23),
            "::",
            stringify!(SidListLength),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_23 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24 {
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_24),
            "::",
            stringify!(Length),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    pub Type: DEVICE_RELATION_TYPE,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25),
            "::",
            stringify!(Type),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_25 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    pub InterfaceType: *const GUID,
    pub Size: USHORT,
    pub Version: USHORT,
    pub Interface: PINTERFACE,
    pub InterfaceSpecificData: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterfaceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(InterfaceType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(Version),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(Interface),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InterfaceSpecificData) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26),
            "::",
            stringify!(InterfaceSpecificData),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_26 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    pub Capabilities: PDEVICE_CAPABILITIES,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Capabilities) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27),
            "::",
            stringify!(Capabilities),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_27 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    pub IoResourceRequirementList: PIO_RESOURCE_REQUIREMENTS_LIST,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).IoResourceRequirementList) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28),
            "::",
            stringify!(IoResourceRequirementList),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_28 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    pub WhichSpace: ULONG,
    pub Buffer: PVOID,
    pub Offset: ULONG,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WhichSpace) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29),
            "::",
            stringify!(WhichSpace),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29),
            "::",
            stringify!(Buffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29),
            "::",
            stringify!(Offset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29),
            "::",
            stringify!(Length),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_29 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30 {
    pub Lock: BOOLEAN,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30>(),
        1usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_30),
            "::",
            stringify!(Lock),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    pub IdType: BUS_QUERY_ID_TYPE::Type,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IdType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31),
            "::",
            stringify!(IdType),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_31 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    pub DeviceTextType: DEVICE_TEXT_TYPE::Type,
    pub __bindgen_padding_0: u32,
    pub LocaleId: LCID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceTextType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32),
            "::",
            stringify!(DeviceTextType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LocaleId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32),
            "::",
            stringify!(LocaleId),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_32 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    pub InPath: BOOLEAN,
    pub Reserved: [BOOLEAN; 3usize],
    pub __bindgen_padding_0: u32,
    pub Type: DEVICE_USAGE_NOTIFICATION_TYPE,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InPath) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33),
            "::",
            stringify!(InPath),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33),
            "::",
            stringify!(Reserved),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33),
            "::",
            stringify!(Type),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_33 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    pub PowerState: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PowerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34),
            "::",
            stringify!(PowerState),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_34 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    pub PowerSequence: PPOWER_SEQUENCE,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PowerSequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35),
            "::",
            stringify!(PowerSequence),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_35 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    pub __bindgen_anon_1: _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1,
    pub __bindgen_padding_0: u32,
    pub Type: POWER_STATE_TYPE,
    pub __bindgen_padding_1: u32,
    pub State: POWER_STATE,
    pub __bindgen_padding_2: u32,
    pub ShutdownType: POWER_ACTION::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1 {
    pub SystemContext: ULONG,
    pub SystemPowerStateContext: SYSTEM_POWER_STATE_CONTEXT,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1),
            "::",
            stringify!(SystemContext),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SystemPowerStateContext) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1),
            "::",
            stringify!(SystemPowerStateContext),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36),
            "::",
            stringify!(Type),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36),
            "::",
            stringify!(State),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShutdownType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36),
            "::",
            stringify!(ShutdownType),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_36 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    pub AllocatedResources: PCM_RESOURCE_LIST,
    pub AllocatedResourcesTranslated: PCM_RESOURCE_LIST,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AllocatedResources) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37),
            "::",
            stringify!(AllocatedResources),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AllocatedResourcesTranslated) as usize
                - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37),
            "::",
            stringify!(AllocatedResourcesTranslated),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_37 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    pub ProviderId: ULONG_PTR,
    pub DataPath: PVOID,
    pub BufferSize: ULONG,
    pub Buffer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ProviderId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38),
            "::",
            stringify!(ProviderId),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataPath) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38),
            "::",
            stringify!(DataPath),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BufferSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38),
            "::",
            stringify!(BufferSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38),
            "::",
            stringify!(Buffer),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_38 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39 {
    pub Argument1: PVOID,
    pub Argument2: PVOID,
    pub Argument3: PVOID,
    pub Argument4: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Argument1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39),
            "::",
            stringify!(Argument1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Argument2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39),
            "::",
            stringify!(Argument2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Argument3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39),
            "::",
            stringify!(Argument3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Argument4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39),
            "::",
            stringify!(Argument4),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1__bindgen_ty_39 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_STACK_LOCATION__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STACK_LOCATION__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Create) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Create),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreatePipe) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(CreatePipe),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreateMailslot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(CreateMailslot),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Read),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Write),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryDirectory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryDirectory),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NotifyDirectory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(NotifyDirectory),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NotifyDirectoryEx) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(NotifyDirectoryEx),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryFile),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetFile),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryEa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryEa),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetEa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetEa),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryVolume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryVolume),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetVolume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetVolume),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileSystemControl) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(FileSystemControl),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockControl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(LockControl),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceIoControl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(DeviceIoControl),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuerySecurity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QuerySecurity),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetSecurity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetSecurity),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MountVolume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(MountVolume),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VerifyVolume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(VerifyVolume),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Scsi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Scsi),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryQuota) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryQuota),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetQuota) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetQuota),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).QueryDeviceRelations) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryDeviceRelations),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryInterface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryInterface),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DeviceCapabilities) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(DeviceCapabilities),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FilterResourceRequirements) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(FilterResourceRequirements),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadWriteConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(ReadWriteConfig),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetLock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(SetLock),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryId),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryDeviceText) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(QueryDeviceText),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).UsageNotification) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(UsageNotification),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitWake) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(WaitWake),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PowerSequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(PowerSequence),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Power) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Power),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartDevice) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(StartDevice),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WMI) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(WMI),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Others) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION__bindgen_ty_1),
            "::",
            stringify!(Others),
        ),
    );
}
impl Default for _IO_STACK_LOCATION__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IO_STACK_LOCATION() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_STACK_LOCATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STACK_LOCATION>(),
        72usize,
        concat!("Size of: ", stringify!(_IO_STACK_LOCATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STACK_LOCATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STACK_LOCATION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorFunction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(MajorFunction),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinorFunction) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(MinorFunction),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Control) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(Control),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parameters) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(Parameters),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(DeviceObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileObject) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(FileObject),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CompletionRoutine) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(CompletionRoutine),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Context) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STACK_LOCATION),
            "::",
            stringify!(Context),
        ),
    );
}
impl Default for _IO_STACK_LOCATION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IO_CSQ = _IO_CSQ;
pub type PIO_CSQ = *mut _IO_CSQ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CSQ_IRP_CONTEXT {
    pub Type: ULONG,
    pub Irp: PIRP,
    pub Csq: PIO_CSQ,
}
#[test]
fn bindgen_test_layout__IO_CSQ_IRP_CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_CSQ_IRP_CONTEXT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_CSQ_IRP_CONTEXT>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_CSQ_IRP_CONTEXT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_CSQ_IRP_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_CSQ_IRP_CONTEXT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_CSQ_IRP_CONTEXT),
            "::",
            stringify!(Type),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Irp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_CSQ_IRP_CONTEXT),
            "::",
            stringify!(Irp),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Csq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_CSQ_IRP_CONTEXT),
            "::",
            stringify!(Csq),
        ),
    );
}
impl Default for _IO_CSQ_IRP_CONTEXT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IO_CSQ_IRP_CONTEXT = _IO_CSQ_IRP_CONTEXT;
pub type IO_CSQ_INSERT_IRP = ::core::option::Option<
    unsafe extern "C" fn(Csq: *mut _IO_CSQ, Irp: PIRP),
>;
pub type PIO_CSQ_INSERT_IRP = IO_CSQ_INSERT_IRP;
pub type IO_CSQ_REMOVE_IRP = ::core::option::Option<
    unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP),
>;
pub type PIO_CSQ_REMOVE_IRP = IO_CSQ_REMOVE_IRP;
pub type IO_CSQ_PEEK_NEXT_IRP = ::core::option::Option<
    unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP, PeekContext: PVOID) -> PIRP,
>;
pub type PIO_CSQ_PEEK_NEXT_IRP = IO_CSQ_PEEK_NEXT_IRP;
pub type IO_CSQ_ACQUIRE_LOCK = ::core::option::Option<
    unsafe extern "C" fn(Csq: PIO_CSQ, Irql: PKIRQL),
>;
pub type PIO_CSQ_ACQUIRE_LOCK = IO_CSQ_ACQUIRE_LOCK;
pub type IO_CSQ_RELEASE_LOCK = ::core::option::Option<
    unsafe extern "C" fn(Csq: PIO_CSQ, Irql: KIRQL),
>;
pub type PIO_CSQ_RELEASE_LOCK = IO_CSQ_RELEASE_LOCK;
pub type IO_CSQ_COMPLETE_CANCELED_IRP = ::core::option::Option<
    unsafe extern "C" fn(Csq: PIO_CSQ, Irp: PIRP),
>;
pub type PIO_CSQ_COMPLETE_CANCELED_IRP = IO_CSQ_COMPLETE_CANCELED_IRP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_CSQ {
    pub Type: ULONG,
    pub CsqInsertIrp: PIO_CSQ_INSERT_IRP,
    pub CsqRemoveIrp: PIO_CSQ_REMOVE_IRP,
    pub CsqPeekNextIrp: PIO_CSQ_PEEK_NEXT_IRP,
    pub CsqAcquireLock: PIO_CSQ_ACQUIRE_LOCK,
    pub CsqReleaseLock: PIO_CSQ_RELEASE_LOCK,
    pub CsqCompleteCanceledIrp: PIO_CSQ_COMPLETE_CANCELED_IRP,
    pub ReservePointer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_CSQ() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_CSQ> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_CSQ>(),
        64usize,
        concat!("Size of: ", stringify!(_IO_CSQ)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_CSQ>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_CSQ)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_IO_CSQ), "::", stringify!(Type)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CsqInsertIrp) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_IO_CSQ), "::", stringify!(CsqInsertIrp)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CsqRemoveIrp) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(_IO_CSQ), "::", stringify!(CsqRemoveIrp)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CsqPeekNextIrp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_CSQ),
            "::",
            stringify!(CsqPeekNextIrp),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CsqAcquireLock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_CSQ),
            "::",
            stringify!(CsqAcquireLock),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CsqReleaseLock) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_CSQ),
            "::",
            stringify!(CsqReleaseLock),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CsqCompleteCanceledIrp) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_CSQ),
            "::",
            stringify!(CsqCompleteCanceledIrp),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReservePointer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_CSQ),
            "::",
            stringify!(ReservePointer),
        ),
    );
}
impl Default for _IO_CSQ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTRANSACTION {
    _unused: [u8; 0],
}
pub type PKTRANSACTION = *mut _KTRANSACTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EJOB {
    _unused: [u8; 0],
}
pub type PESILO = *mut _EJOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TXN_PARAMETER_BLOCK {
    pub Length: USHORT,
    pub TxFsContext: USHORT,
    pub TransactionObject: PVOID,
}
#[test]
fn bindgen_test_layout__TXN_PARAMETER_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_TXN_PARAMETER_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_TXN_PARAMETER_BLOCK>(),
        16usize,
        concat!("Size of: ", stringify!(_TXN_PARAMETER_BLOCK)),
    );
    assert_eq!(
        ::core::mem::align_of::<_TXN_PARAMETER_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_TXN_PARAMETER_BLOCK)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TXN_PARAMETER_BLOCK),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TxFsContext) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_TXN_PARAMETER_BLOCK),
            "::",
            stringify!(TxFsContext),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TransactionObject) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TXN_PARAMETER_BLOCK),
            "::",
            stringify!(TransactionObject),
        ),
    );
}
impl Default for _TXN_PARAMETER_BLOCK {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PTXN_PARAMETER_BLOCK = *mut _TXN_PARAMETER_BLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_DRIVER_CREATE_CONTEXT {
    pub Size: CSHORT,
    pub ExtraCreateParameter: *mut _ECP_LIST,
    pub DeviceObjectHint: PVOID,
    pub TxnParameters: PTXN_PARAMETER_BLOCK,
    pub SiloContext: PESILO,
}
#[test]
fn bindgen_test_layout__IO_DRIVER_CREATE_CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_DRIVER_CREATE_CONTEXT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_DRIVER_CREATE_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(_IO_DRIVER_CREATE_CONTEXT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_DRIVER_CREATE_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_DRIVER_CREATE_CONTEXT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_DRIVER_CREATE_CONTEXT),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ExtraCreateParameter) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_DRIVER_CREATE_CONTEXT),
            "::",
            stringify!(ExtraCreateParameter),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DeviceObjectHint) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_DRIVER_CREATE_CONTEXT),
            "::",
            stringify!(DeviceObjectHint),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TxnParameters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_DRIVER_CREATE_CONTEXT),
            "::",
            stringify!(TxnParameters),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SiloContext) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_DRIVER_CREATE_CONTEXT),
            "::",
            stringify!(SiloContext),
        ),
    );
}
impl Default for _IO_DRIVER_CREATE_CONTEXT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PIO_DRIVER_CREATE_CONTEXT = *mut _IO_DRIVER_CREATE_CONTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [UCHAR; 6usize],
}
#[test]
fn bindgen_test_layout__SID_IDENTIFIER_AUTHORITY() {
    const UNINIT: ::core::mem::MaybeUninit<_SID_IDENTIFIER_AUTHORITY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SID_IDENTIFIER_AUTHORITY>(),
        6usize,
        concat!("Size of: ", stringify!(_SID_IDENTIFIER_AUTHORITY)),
    );
    assert_eq!(
        ::core::mem::align_of::<_SID_IDENTIFIER_AUTHORITY>(),
        1usize,
        concat!("Alignment of ", stringify!(_SID_IDENTIFIER_AUTHORITY)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_IDENTIFIER_AUTHORITY),
            "::",
            stringify!(Value),
        ),
    );
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SID {
    pub Revision: UCHAR,
    pub SubAuthorityCount: UCHAR,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    pub SubAuthority: [ULONG; 1usize],
}
#[test]
fn bindgen_test_layout__SID() {
    const UNINIT: ::core::mem::MaybeUninit<_SID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SID>(),
        12usize,
        concat!("Size of: ", stringify!(_SID)),
    );
    assert_eq!(
        ::core::mem::align_of::<_SID>(),
        4usize,
        concat!("Alignment of ", stringify!(_SID)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_SID), "::", stringify!(Revision)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SubAuthorityCount) as usize - ptr as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthorityCount),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).IdentifierAuthority) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(IdentifierAuthority),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SubAuthority) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_SID), "::", stringify!(SubAuthority)),
    );
}
pub type SID = _SID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_NAMES_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAMES_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NAMES_INFORMATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NAMES_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_NAMES_INFORMATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NAMES_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NAMES_INFORMATION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(NextEntryOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileIndex),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileNameLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileName),
        ),
    );
}
pub type PFILE_NAMES_INFORMATION = *mut _FILE_NAMES_INFORMATION;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_GET_QUOTA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub SidLength: ULONG,
    pub Sid: SID,
}
#[test]
fn bindgen_test_layout__FILE_GET_QUOTA_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_GET_QUOTA_INFORMATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_GET_QUOTA_INFORMATION>(),
        20usize,
        concat!("Size of: ", stringify!(_FILE_GET_QUOTA_INFORMATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_GET_QUOTA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_GET_QUOTA_INFORMATION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_GET_QUOTA_INFORMATION),
            "::",
            stringify!(NextEntryOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SidLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_GET_QUOTA_INFORMATION),
            "::",
            stringify!(SidLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Sid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_GET_QUOTA_INFORMATION),
            "::",
            stringify!(Sid),
        ),
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KQUEUE {
    pub Header: DISPATCHER_HEADER,
    pub EntryListHead: LIST_ENTRY,
    pub CurrentCount: ULONG,
    pub MaximumCount: ULONG,
    pub ThreadListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KQUEUE() {
    const UNINIT: ::core::mem::MaybeUninit<_KQUEUE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KQUEUE>(),
        64usize,
        concat!("Size of: ", stringify!(_KQUEUE)),
    );
    assert_eq!(
        ::core::mem::align_of::<_KQUEUE>(),
        8usize,
        concat!("Alignment of ", stringify!(_KQUEUE)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_KQUEUE), "::", stringify!(Header)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EntryListHead) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(EntryListHead),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentCount) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(_KQUEUE), "::", stringify!(CurrentCount)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumCount) as usize - ptr as usize },
        44usize,
        concat!("Offset of field: ", stringify!(_KQUEUE), "::", stringify!(MaximumCount)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListHead) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(ThreadListHead),
        ),
    );
}
impl Default for _KQUEUE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub mod _FS_FILTER_SECTION_SYNC_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const SyncTypeOther: Type = 0;
    pub const SyncTypeCreateSection: Type = 1;
}
pub use self::_FS_FILTER_SECTION_SYNC_TYPE::Type as FS_FILTER_SECTION_SYNC_TYPE;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FS_FILTER_SECTION_SYNC_OUTPUT {
    pub StructureSize: ULONG,
    pub SizeReturned: ULONG,
    pub Flags: ULONG,
    pub DesiredReadAlignment: ULONG,
}
#[test]
fn bindgen_test_layout__FS_FILTER_SECTION_SYNC_OUTPUT() {
    const UNINIT: ::core::mem::MaybeUninit<_FS_FILTER_SECTION_SYNC_OUTPUT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FS_FILTER_SECTION_SYNC_OUTPUT>(),
        16usize,
        concat!("Size of: ", stringify!(_FS_FILTER_SECTION_SYNC_OUTPUT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FS_FILTER_SECTION_SYNC_OUTPUT>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_FILTER_SECTION_SYNC_OUTPUT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StructureSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_FILTER_SECTION_SYNC_OUTPUT),
            "::",
            stringify!(StructureSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeReturned) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_FILTER_SECTION_SYNC_OUTPUT),
            "::",
            stringify!(SizeReturned),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_FILTER_SECTION_SYNC_OUTPUT),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DesiredReadAlignment) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_FILTER_SECTION_SYNC_OUTPUT),
            "::",
            stringify!(DesiredReadAlignment),
        ),
    );
}
pub type PFS_FILTER_SECTION_SYNC_OUTPUT = *mut _FS_FILTER_SECTION_SYNC_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_PRIORITY_INFO {
    pub Size: ULONG,
    pub ThreadPriority: ULONG,
    pub PagePriority: ULONG,
    pub IoPriority: IO_PRIORITY_HINT,
}
#[test]
fn bindgen_test_layout__IO_PRIORITY_INFO() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_PRIORITY_INFO> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_PRIORITY_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_PRIORITY_INFO)),
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_PRIORITY_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_PRIORITY_INFO)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_PRIORITY_INFO),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadPriority) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_PRIORITY_INFO),
            "::",
            stringify!(ThreadPriority),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PagePriority) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_PRIORITY_INFO),
            "::",
            stringify!(PagePriority),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoPriority) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_PRIORITY_INFO),
            "::",
            stringify!(IoPriority),
        ),
    );
}
impl Default for _IO_PRIORITY_INFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PIO_PRIORITY_INFO = *mut _IO_PRIORITY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COPY_INFORMATION {
    pub SourceFileObject: PFILE_OBJECT,
    pub SourceFileOffset: LONGLONG,
}
#[test]
fn bindgen_test_layout__COPY_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_COPY_INFORMATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_COPY_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_COPY_INFORMATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_COPY_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_COPY_INFORMATION)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SourceFileObject) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_COPY_INFORMATION),
            "::",
            stringify!(SourceFileObject),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SourceFileOffset) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_COPY_INFORMATION),
            "::",
            stringify!(SourceFileOffset),
        ),
    );
}
impl Default for _COPY_INFORMATION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PCOPY_INFORMATION = *mut _COPY_INFORMATION;
pub type POPLOCK = *mut PVOID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LOCK_INFO {
    pub StartingByte: LARGE_INTEGER,
    pub Length: LARGE_INTEGER,
    pub ExclusiveLock: BOOLEAN,
    pub Key: ULONG,
    pub FileObject: PFILE_OBJECT,
    pub ProcessId: PVOID,
    pub EndingByte: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_LOCK_INFO() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_LOCK_INFO> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_LOCK_INFO>(),
        48usize,
        concat!("Size of: ", stringify!(_FILE_LOCK_INFO)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_LOCK_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_LOCK_INFO)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartingByte) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK_INFO),
            "::",
            stringify!(StartingByte),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK_INFO),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExclusiveLock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK_INFO),
            "::",
            stringify!(ExclusiveLock),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        20usize,
        concat!("Offset of field: ", stringify!(_FILE_LOCK_INFO), "::", stringify!(Key)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileObject) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK_INFO),
            "::",
            stringify!(FileObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ProcessId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK_INFO),
            "::",
            stringify!(ProcessId),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndingByte) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK_INFO),
            "::",
            stringify!(EndingByte),
        ),
    );
}
impl Default for _FILE_LOCK_INFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FILE_LOCK_INFO = _FILE_LOCK_INFO;
pub type PFILE_LOCK_INFO = *mut FILE_LOCK_INFO;
pub type PCOMPLETE_LOCK_IRP_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, Irp: PIRP) -> NTSTATUS,
>;
pub type PUNLOCK_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, FileLockInfo: PFILE_LOCK_INFO),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LOCK {
    pub CompleteLockIrpRoutine: PCOMPLETE_LOCK_IRP_ROUTINE,
    pub UnlockRoutine: PUNLOCK_ROUTINE,
    pub FastIoIsQuestionable: BOOLEAN,
    pub SpareC: [BOOLEAN; 3usize],
    pub LockInformation: PVOID,
    pub LastReturnedLockInfo: FILE_LOCK_INFO,
    pub LastReturnedLock: PVOID,
    pub LockRequestsInProgress: LONG,
}
#[test]
fn bindgen_test_layout__FILE_LOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_LOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_LOCK>(),
        96usize,
        concat!("Size of: ", stringify!(_FILE_LOCK)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_LOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_LOCK)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CompleteLockIrpRoutine) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK),
            "::",
            stringify!(CompleteLockIrpRoutine),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UnlockRoutine) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK),
            "::",
            stringify!(UnlockRoutine),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoIsQuestionable) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK),
            "::",
            stringify!(FastIoIsQuestionable),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SpareC) as usize - ptr as usize },
        17usize,
        concat!("Offset of field: ", stringify!(_FILE_LOCK), "::", stringify!(SpareC)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockInformation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK),
            "::",
            stringify!(LockInformation),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).LastReturnedLockInfo) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK),
            "::",
            stringify!(LastReturnedLockInfo),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).LastReturnedLock) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK),
            "::",
            stringify!(LastReturnedLock),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).LockRequestsInProgress) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LOCK),
            "::",
            stringify!(LockRequestsInProgress),
        ),
    );
}
impl Default for _FILE_LOCK {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FILE_LOCK = _FILE_LOCK;
pub type PFILE_LOCK = *mut FILE_LOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REAL_NOTIFY_SYNC {
    _unused: [u8; 0],
}
pub type PNOTIFY_SYNC = *mut _REAL_NOTIFY_SYNC;
pub type PCHECK_FOR_TRAVERSE_ACCESS = ::core::option::Option<
    unsafe extern "C" fn(
        NotifyContext: PVOID,
        TargetContext: PVOID,
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
    ) -> BOOLEAN,
>;
pub type PFILTER_REPORT_CHANGE = ::core::option::Option<
    unsafe extern "C" fn(NotifyContext: PVOID, FilterContext: PVOID) -> BOOLEAN,
>;
pub type PECP_LIST = *mut _ECP_LIST;
pub type PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(EcpContext: PVOID, EcpType: LPCGUID),
>;
pub type FSRTL_ALLOCATE_ECPLIST_FLAGS = ULONG;
pub type FSRTL_ALLOCATE_ECP_FLAGS = ULONG;
pub type FSRTL_ECP_LOOKASIDE_FLAGS = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OPEN_REPARSE_LIST_ENTRY {
    pub OpenReparseListEntry: LIST_ENTRY,
    pub ReparseTag: ULONG,
    pub Flags: ULONG,
    pub ReparseGuid: GUID,
    pub Size: USHORT,
    pub RemainingLength: USHORT,
}
#[test]
fn bindgen_test_layout__OPEN_REPARSE_LIST_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_OPEN_REPARSE_LIST_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OPEN_REPARSE_LIST_ENTRY>(),
        48usize,
        concat!("Size of: ", stringify!(_OPEN_REPARSE_LIST_ENTRY)),
    );
    assert_eq!(
        ::core::mem::align_of::<_OPEN_REPARSE_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_OPEN_REPARSE_LIST_ENTRY)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OpenReparseListEntry) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OPEN_REPARSE_LIST_ENTRY),
            "::",
            stringify!(OpenReparseListEntry),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReparseTag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OPEN_REPARSE_LIST_ENTRY),
            "::",
            stringify!(ReparseTag),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OPEN_REPARSE_LIST_ENTRY),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReparseGuid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_OPEN_REPARSE_LIST_ENTRY),
            "::",
            stringify!(ReparseGuid),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_OPEN_REPARSE_LIST_ENTRY),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RemainingLength) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_OPEN_REPARSE_LIST_ENTRY),
            "::",
            stringify!(RemainingLength),
        ),
    );
}
impl Default for _OPEN_REPARSE_LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type POPEN_REPARSE_LIST_ENTRY = *mut _OPEN_REPARSE_LIST_ENTRY;
pub mod _FLT_FILESYSTEM_TYPE {
    pub type Type = ::core::ffi::c_int;
    pub const FLT_FSTYPE_UNKNOWN: Type = 0;
    pub const FLT_FSTYPE_RAW: Type = 1;
    pub const FLT_FSTYPE_NTFS: Type = 2;
    pub const FLT_FSTYPE_FAT: Type = 3;
    pub const FLT_FSTYPE_CDFS: Type = 4;
    pub const FLT_FSTYPE_UDFS: Type = 5;
    pub const FLT_FSTYPE_LANMAN: Type = 6;
    pub const FLT_FSTYPE_WEBDAV: Type = 7;
    pub const FLT_FSTYPE_RDPDR: Type = 8;
    pub const FLT_FSTYPE_NFS: Type = 9;
    pub const FLT_FSTYPE_MS_NETWARE: Type = 10;
    pub const FLT_FSTYPE_NETWARE: Type = 11;
    pub const FLT_FSTYPE_BSUDF: Type = 12;
    pub const FLT_FSTYPE_MUP: Type = 13;
    pub const FLT_FSTYPE_RSFX: Type = 14;
    pub const FLT_FSTYPE_ROXIO_UDF1: Type = 15;
    pub const FLT_FSTYPE_ROXIO_UDF2: Type = 16;
    pub const FLT_FSTYPE_ROXIO_UDF3: Type = 17;
    pub const FLT_FSTYPE_TACIT: Type = 18;
    pub const FLT_FSTYPE_FS_REC: Type = 19;
    pub const FLT_FSTYPE_INCD: Type = 20;
    pub const FLT_FSTYPE_INCD_FAT: Type = 21;
    pub const FLT_FSTYPE_EXFAT: Type = 22;
    pub const FLT_FSTYPE_PSFS: Type = 23;
    pub const FLT_FSTYPE_GPFS: Type = 24;
    pub const FLT_FSTYPE_NPFS: Type = 25;
    pub const FLT_FSTYPE_MSFS: Type = 26;
    pub const FLT_FSTYPE_CSVFS: Type = 27;
    pub const FLT_FSTYPE_REFS: Type = 28;
    pub const FLT_FSTYPE_OPENAFS: Type = 29;
    pub const FLT_FSTYPE_CIMFS: Type = 30;
}
pub use self::_FLT_FILESYSTEM_TYPE::Type as FLT_FILESYSTEM_TYPE;
pub type PFLT_FILESYSTEM_TYPE = *mut _FLT_FILESYSTEM_TYPE::Type;
pub mod _FILTER_INFORMATION_CLASS {
    pub type Type = ::core::ffi::c_int;
    pub const FilterFullInformation: Type = 0;
    pub const FilterAggregateBasicInformation: Type = 1;
    pub const FilterAggregateStandardInformation: Type = 2;
}
pub use self::_FILTER_INFORMATION_CLASS::Type as FILTER_INFORMATION_CLASS;
pub mod _FILTER_VOLUME_INFORMATION_CLASS {
    pub type Type = ::core::ffi::c_int;
    pub const FilterVolumeBasicInformation: Type = 0;
    pub const FilterVolumeStandardInformation: Type = 1;
}
pub use self::_FILTER_VOLUME_INFORMATION_CLASS::Type as FILTER_VOLUME_INFORMATION_CLASS;
pub mod _INSTANCE_INFORMATION_CLASS {
    pub type Type = ::core::ffi::c_int;
    pub const InstanceBasicInformation: Type = 0;
    pub const InstancePartialInformation: Type = 1;
    pub const InstanceFullInformation: Type = 2;
    pub const InstanceAggregateStandardInformation: Type = 3;
}
pub use self::_INSTANCE_INFORMATION_CLASS::Type as INSTANCE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_FILTER {
    _unused: [u8; 0],
}
pub type PFLT_FILTER = *mut _FLT_FILTER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_VOLUME {
    _unused: [u8; 0],
}
pub type PFLT_VOLUME = *mut _FLT_VOLUME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_INSTANCE {
    _unused: [u8; 0],
}
pub type PFLT_INSTANCE = *mut _FLT_INSTANCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PORT {
    _unused: [u8; 0],
}
pub type PFLT_PORT = *mut _FLT_PORT;
pub type PFLT_CONTEXT = PVOID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FLT_PARAMETERS {
    pub Create: _FLT_PARAMETERS__bindgen_ty_1,
    pub CreatePipe: _FLT_PARAMETERS__bindgen_ty_2,
    pub CreateMailslot: _FLT_PARAMETERS__bindgen_ty_3,
    pub Read: _FLT_PARAMETERS__bindgen_ty_4,
    pub Write: _FLT_PARAMETERS__bindgen_ty_5,
    pub QueryFileInformation: _FLT_PARAMETERS__bindgen_ty_6,
    pub SetFileInformation: _FLT_PARAMETERS__bindgen_ty_7,
    pub QueryEa: _FLT_PARAMETERS__bindgen_ty_8,
    pub SetEa: _FLT_PARAMETERS__bindgen_ty_9,
    pub QueryVolumeInformation: _FLT_PARAMETERS__bindgen_ty_10,
    pub SetVolumeInformation: _FLT_PARAMETERS__bindgen_ty_11,
    pub DirectoryControl: _FLT_PARAMETERS__bindgen_ty_12,
    pub FileSystemControl: _FLT_PARAMETERS__bindgen_ty_13,
    pub DeviceIoControl: _FLT_PARAMETERS__bindgen_ty_14,
    pub LockControl: _FLT_PARAMETERS__bindgen_ty_15,
    pub QuerySecurity: _FLT_PARAMETERS__bindgen_ty_16,
    pub SetSecurity: _FLT_PARAMETERS__bindgen_ty_17,
    pub WMI: _FLT_PARAMETERS__bindgen_ty_18,
    pub QueryQuota: _FLT_PARAMETERS__bindgen_ty_19,
    pub SetQuota: _FLT_PARAMETERS__bindgen_ty_20,
    pub Pnp: _FLT_PARAMETERS__bindgen_ty_21,
    pub AcquireForSectionSynchronization: _FLT_PARAMETERS__bindgen_ty_22,
    pub AcquireForModifiedPageWriter: _FLT_PARAMETERS__bindgen_ty_23,
    pub ReleaseForModifiedPageWriter: _FLT_PARAMETERS__bindgen_ty_24,
    pub QueryOpen: _FLT_PARAMETERS__bindgen_ty_25,
    pub FastIoCheckIfPossible: _FLT_PARAMETERS__bindgen_ty_26,
    pub NetworkQueryOpen: _FLT_PARAMETERS__bindgen_ty_27,
    pub MdlRead: _FLT_PARAMETERS__bindgen_ty_28,
    pub MdlReadComplete: _FLT_PARAMETERS__bindgen_ty_29,
    pub PrepareMdlWrite: _FLT_PARAMETERS__bindgen_ty_30,
    pub MdlWriteComplete: _FLT_PARAMETERS__bindgen_ty_31,
    pub MountVolume: _FLT_PARAMETERS__bindgen_ty_32,
    pub Others: _FLT_PARAMETERS__bindgen_ty_33,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_1 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub FileAttributes: USHORT,
    pub ShareAccess: USHORT,
    pub __bindgen_padding_1: u32,
    pub EaLength: ULONG,
    pub EaBuffer: PVOID,
    pub AllocationSize: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SecurityContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_1),
            "::",
            stringify!(SecurityContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Options) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_1),
            "::",
            stringify!(Options),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_1),
            "::",
            stringify!(FileAttributes),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShareAccess) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_1),
            "::",
            stringify!(ShareAccess),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaLength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_1),
            "::",
            stringify!(EaLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_1),
            "::",
            stringify!(EaBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_1),
            "::",
            stringify!(AllocationSize),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_2 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_2)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SecurityContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_2),
            "::",
            stringify!(SecurityContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Options) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_2),
            "::",
            stringify!(Options),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_2),
            "::",
            stringify!(Reserved),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShareAccess) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_2),
            "::",
            stringify!(ShareAccess),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parameters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_2),
            "::",
            stringify!(Parameters),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_3 {
    pub SecurityContext: PIO_SECURITY_CONTEXT,
    pub Options: ULONG,
    pub __bindgen_padding_0: [u16; 2usize],
    pub Reserved: USHORT,
    pub ShareAccess: USHORT,
    pub Parameters: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_3> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_3>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_3)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_3)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SecurityContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_3),
            "::",
            stringify!(SecurityContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Options) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_3),
            "::",
            stringify!(Options),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_3),
            "::",
            stringify!(Reserved),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShareAccess) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_3),
            "::",
            stringify!(ShareAccess),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parameters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_3),
            "::",
            stringify!(Parameters),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_4 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
    pub ReadBuffer: PVOID,
    pub MdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_4> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_4>(),
        40usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_4)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_4)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_4),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_4),
            "::",
            stringify!(Key),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ByteOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_4),
            "::",
            stringify!(ByteOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_4),
            "::",
            stringify!(ReadBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_4),
            "::",
            stringify!(MdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_5 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
    pub WriteBuffer: PVOID,
    pub MdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_5> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_5>(),
        40usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_5)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_5)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_5),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_5),
            "::",
            stringify!(Key),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ByteOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_5),
            "::",
            stringify!(ByteOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WriteBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_5),
            "::",
            stringify!(WriteBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_5),
            "::",
            stringify!(MdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_6 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub InfoBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_6() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_6> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_6>(),
        24usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_6)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_6)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_6),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileInformationClass) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_6),
            "::",
            stringify!(FileInformationClass),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InfoBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_6),
            "::",
            stringify!(InfoBuffer),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_7 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub ParentOfTarget: PFILE_OBJECT,
    pub __bindgen_anon_1: _FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1,
    pub InfoBuffer: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1 {
    pub __bindgen_anon_1: _FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1,
    pub ClusterCount: ULONG,
    pub DeleteHandle: HANDLE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub AdvanceOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<
            _FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1,
        >(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<
            _FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReplaceIfExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ReplaceIfExists),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AdvanceOnly) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AdvanceOnly),
        ),
    );
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClusterCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1),
            "::",
            stringify!(ClusterCount),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeleteHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1),
            "::",
            stringify!(DeleteHandle),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_7__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_7() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_7> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_7>(),
        40usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_7)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_7)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_7),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileInformationClass) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_7),
            "::",
            stringify!(FileInformationClass),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ParentOfTarget) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_7),
            "::",
            stringify!(ParentOfTarget),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InfoBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_7),
            "::",
            stringify!(InfoBuffer),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_8 {
    pub Length: ULONG,
    pub EaList: PVOID,
    pub EaListLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub EaIndex: ULONG,
    pub EaBuffer: PVOID,
    pub MdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_8() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_8> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_8>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_8)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_8>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_8)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_8),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaList) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_8),
            "::",
            stringify!(EaList),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaListLength) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_8),
            "::",
            stringify!(EaListLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_8),
            "::",
            stringify!(EaIndex),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_8),
            "::",
            stringify!(EaBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_8),
            "::",
            stringify!(MdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_9 {
    pub Length: ULONG,
    pub EaBuffer: PVOID,
    pub MdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_9() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_9> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_9>(),
        24usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_9)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_9>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_9)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_9),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_9),
            "::",
            stringify!(EaBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_9),
            "::",
            stringify!(MdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_10 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
    pub VolumeBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_10() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_10> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_10>(),
        24usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_10)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_10>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_10)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_10),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FsInformationClass) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_10),
            "::",
            stringify!(FsInformationClass),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_10),
            "::",
            stringify!(VolumeBuffer),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_11 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub FsInformationClass: FS_INFORMATION_CLASS,
    pub VolumeBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_11() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_11> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_11>(),
        24usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_11)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_11>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_11)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_11),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FsInformationClass) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_11),
            "::",
            stringify!(FsInformationClass),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_11),
            "::",
            stringify!(VolumeBuffer),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_11 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FLT_PARAMETERS__bindgen_ty_12 {
    pub QueryDirectory: _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1,
    pub NotifyDirectory: _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2,
    pub NotifyDirectoryEx: _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1 {
    pub Length: ULONG,
    pub FileName: PUNICODE_STRING,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
    pub __bindgen_padding_0: u32,
    pub FileIndex: ULONG,
    pub DirectoryBuffer: PVOID,
    pub MdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1),
            "::",
            stringify!(FileName),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileInformationClass) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1),
            "::",
            stringify!(FileInformationClass),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1),
            "::",
            stringify!(FileIndex),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DirectoryBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1),
            "::",
            stringify!(DirectoryBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1),
            "::",
            stringify!(MdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
    pub __bindgen_padding_1: u32,
    pub Spare1: ULONG,
    pub __bindgen_padding_2: u32,
    pub Spare2: ULONG,
    pub DirectoryBuffer: PVOID,
    pub MdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CompletionFilter) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2),
            "::",
            stringify!(CompletionFilter),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Spare1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2),
            "::",
            stringify!(Spare1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Spare2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2),
            "::",
            stringify!(Spare2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DirectoryBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2),
            "::",
            stringify!(DirectoryBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2),
            "::",
            stringify!(MdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3 {
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub CompletionFilter: ULONG,
    pub __bindgen_padding_1: u32,
    pub DirectoryNotifyInformationClass: DIRECTORY_NOTIFY_INFORMATION_CLASS,
    pub __bindgen_padding_2: u32,
    pub Spare2: ULONG,
    pub DirectoryBuffer: PVOID,
    pub MdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CompletionFilter) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3),
            "::",
            stringify!(CompletionFilter),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DirectoryNotifyInformationClass) as usize
                - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3),
            "::",
            stringify!(DirectoryNotifyInformationClass),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Spare2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3),
            "::",
            stringify!(Spare2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DirectoryBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3),
            "::",
            stringify!(DirectoryBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3),
            "::",
            stringify!(MdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_12__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_12() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_12> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_12>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_12)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_12>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_12)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryDirectory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12),
            "::",
            stringify!(QueryDirectory),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NotifyDirectory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12),
            "::",
            stringify!(NotifyDirectory),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NotifyDirectoryEx) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_12),
            "::",
            stringify!(NotifyDirectoryEx),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FLT_PARAMETERS__bindgen_ty_13 {
    pub VerifyVolume: _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1,
    pub Common: _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2,
    pub Neither: _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3,
    pub Buffered: _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4,
    pub Direct: _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1 {
    pub Vpb: PVPB,
    pub DeviceObject: PDEVICE_OBJECT,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Vpb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1),
            "::",
            stringify!(Vpb),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1),
            "::",
            stringify!(DeviceObject),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub FsControlCode: ULONG,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_2),
            "::",
            stringify!(FsControlCode),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub FsControlCode: ULONG,
    pub InputBuffer: PVOID,
    pub OutputBuffer: PVOID,
    pub OutputMdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3),
            "::",
            stringify!(FsControlCode),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3),
            "::",
            stringify!(InputBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3),
            "::",
            stringify!(OutputBuffer),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputMdlAddress) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3),
            "::",
            stringify!(OutputMdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub FsControlCode: ULONG,
    pub SystemBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4),
            "::",
            stringify!(FsControlCode),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4),
            "::",
            stringify!(SystemBuffer),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub FsControlCode: ULONG,
    pub InputSystemBuffer: PVOID,
    pub OutputBuffer: PVOID,
    pub OutputMdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5),
            "::",
            stringify!(FsControlCode),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputSystemBuffer) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5),
            "::",
            stringify!(InputSystemBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5),
            "::",
            stringify!(OutputBuffer),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputMdlAddress) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5),
            "::",
            stringify!(OutputMdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_13__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_13() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_13> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_13>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_13)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_13>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_13)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VerifyVolume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13),
            "::",
            stringify!(VerifyVolume),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13),
            "::",
            stringify!(Common),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Neither) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13),
            "::",
            stringify!(Neither),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffered) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13),
            "::",
            stringify!(Buffered),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Direct) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_13),
            "::",
            stringify!(Direct),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_13 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FLT_PARAMETERS__bindgen_ty_14 {
    pub Common: _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1,
    pub Neither: _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2,
    pub Buffered: _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3,
    pub Direct: _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4,
    pub FastIo: _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub IoControlCode: ULONG,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_1),
            "::",
            stringify!(IoControlCode),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub IoControlCode: ULONG,
    pub InputBuffer: PVOID,
    pub OutputBuffer: PVOID,
    pub OutputMdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2),
            "::",
            stringify!(IoControlCode),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2),
            "::",
            stringify!(InputBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2),
            "::",
            stringify!(OutputBuffer),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputMdlAddress) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2),
            "::",
            stringify!(OutputMdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub IoControlCode: ULONG,
    pub SystemBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3),
            "::",
            stringify!(IoControlCode),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3),
            "::",
            stringify!(SystemBuffer),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub IoControlCode: ULONG,
    pub InputSystemBuffer: PVOID,
    pub OutputBuffer: PVOID,
    pub OutputMdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4),
            "::",
            stringify!(IoControlCode),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputSystemBuffer) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4),
            "::",
            stringify!(InputSystemBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4),
            "::",
            stringify!(OutputBuffer),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputMdlAddress) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4),
            "::",
            stringify!(OutputMdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5 {
    pub OutputBufferLength: ULONG,
    pub __bindgen_padding_0: u32,
    pub InputBufferLength: ULONG,
    pub __bindgen_padding_1: u32,
    pub IoControlCode: ULONG,
    pub InputBuffer: PVOID,
    pub OutputBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5>(),
        40usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputBufferLength) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5),
            "::",
            stringify!(OutputBufferLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InputBufferLength) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5),
            "::",
            stringify!(InputBufferLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5),
            "::",
            stringify!(IoControlCode),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5),
            "::",
            stringify!(InputBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5),
            "::",
            stringify!(OutputBuffer),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_14__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_14() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_14> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_14>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_14)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_14>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_14)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14),
            "::",
            stringify!(Common),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Neither) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14),
            "::",
            stringify!(Neither),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffered) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14),
            "::",
            stringify!(Buffered),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Direct) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14),
            "::",
            stringify!(Direct),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FastIo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_14),
            "::",
            stringify!(FastIo),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_14 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_15 {
    pub Length: PLARGE_INTEGER,
    pub Key: ULONG,
    pub ByteOffset: LARGE_INTEGER,
    pub ProcessId: PEPROCESS,
    pub FailImmediately: BOOLEAN,
    pub ExclusiveLock: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_15() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_15> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_15>(),
        40usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_15)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_15>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_15)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_15),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_15),
            "::",
            stringify!(Key),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ByteOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_15),
            "::",
            stringify!(ByteOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ProcessId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_15),
            "::",
            stringify!(ProcessId),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FailImmediately) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_15),
            "::",
            stringify!(FailImmediately),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExclusiveLock) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_15),
            "::",
            stringify!(ExclusiveLock),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_15 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_16 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
    pub SecurityBuffer: PVOID,
    pub MdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_16() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_16> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_16>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_16)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_16>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_16)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityInformation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_16),
            "::",
            stringify!(SecurityInformation),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_16),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SecurityBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_16),
            "::",
            stringify!(SecurityBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_16),
            "::",
            stringify!(MdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_16 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_17 {
    pub SecurityInformation: SECURITY_INFORMATION,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_17() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_17> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_17>(),
        16usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_17)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_17>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_17)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityInformation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_17),
            "::",
            stringify!(SecurityInformation),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_17),
            "::",
            stringify!(SecurityDescriptor),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_17 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_18 {
    pub ProviderId: ULONG_PTR,
    pub DataPath: PVOID,
    pub BufferSize: ULONG,
    pub Buffer: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_18() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_18> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_18>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_18)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_18>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_18)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ProviderId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_18),
            "::",
            stringify!(ProviderId),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataPath) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_18),
            "::",
            stringify!(DataPath),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BufferSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_18),
            "::",
            stringify!(BufferSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_18),
            "::",
            stringify!(Buffer),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_18 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_19 {
    pub Length: ULONG,
    pub StartSid: PSID,
    pub SidList: PFILE_GET_QUOTA_INFORMATION,
    pub SidListLength: ULONG,
    pub QuotaBuffer: PVOID,
    pub MdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_19() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_19> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_19>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_19)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_19>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_19)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_19),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartSid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_19),
            "::",
            stringify!(StartSid),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SidList) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_19),
            "::",
            stringify!(SidList),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SidListLength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_19),
            "::",
            stringify!(SidListLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_19),
            "::",
            stringify!(QuotaBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_19),
            "::",
            stringify!(MdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_19 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_20 {
    pub Length: ULONG,
    pub QuotaBuffer: PVOID,
    pub MdlAddress: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_20() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_20> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_20>(),
        24usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_20)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_20>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_20)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_20),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_20),
            "::",
            stringify!(QuotaBuffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_20),
            "::",
            stringify!(MdlAddress),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_20 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FLT_PARAMETERS__bindgen_ty_21 {
    pub StartDevice: _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1,
    pub QueryDeviceRelations: _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_2,
    pub QueryInterface: _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3,
    pub DeviceCapabilities: _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_4,
    pub FilterResourceRequirements: _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_5,
    pub ReadWriteConfig: _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6,
    pub SetLock: _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_7,
    pub QueryId: _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_8,
    pub QueryDeviceText: _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9,
    pub UsageNotification: _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1 {
    pub AllocatedResources: PCM_RESOURCE_LIST,
    pub AllocatedResourcesTranslated: PCM_RESOURCE_LIST,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AllocatedResources) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1),
            "::",
            stringify!(AllocatedResources),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AllocatedResourcesTranslated) as usize
                - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1),
            "::",
            stringify!(AllocatedResourcesTranslated),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_2 {
    pub Type: DEVICE_RELATION_TYPE,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_2)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_2),
            "::",
            stringify!(Type),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3 {
    pub InterfaceType: *const GUID,
    pub Size: USHORT,
    pub Version: USHORT,
    pub Interface: PINTERFACE,
    pub InterfaceSpecificData: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterfaceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3),
            "::",
            stringify!(InterfaceType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3),
            "::",
            stringify!(Version),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3),
            "::",
            stringify!(Interface),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InterfaceSpecificData) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3),
            "::",
            stringify!(InterfaceSpecificData),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_4 {
    pub Capabilities: PDEVICE_CAPABILITIES,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_4,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_4)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_4),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Capabilities) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_4),
            "::",
            stringify!(Capabilities),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_5 {
    pub IoResourceRequirementList: PIO_RESOURCE_REQUIREMENTS_LIST,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_5,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_5)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_5),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).IoResourceRequirementList) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_5),
            "::",
            stringify!(IoResourceRequirementList),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6 {
    pub WhichSpace: ULONG,
    pub Buffer: PVOID,
    pub Offset: ULONG,
    pub __bindgen_padding_0: u32,
    pub Length: ULONG,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WhichSpace) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6),
            "::",
            stringify!(WhichSpace),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6),
            "::",
            stringify!(Buffer),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6),
            "::",
            stringify!(Offset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6),
            "::",
            stringify!(Length),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_7 {
    pub Lock: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_7() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_7,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_7>(),
        1usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_7)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_7>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_7),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_7),
            "::",
            stringify!(Lock),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_8 {
    pub IdType: BUS_QUERY_ID_TYPE::Type,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_8() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_8,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_8>(),
        4usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_8)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_8>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_8),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IdType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_8),
            "::",
            stringify!(IdType),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9 {
    pub DeviceTextType: DEVICE_TEXT_TYPE::Type,
    pub __bindgen_padding_0: u32,
    pub LocaleId: LCID,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9>(),
        16usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceTextType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9),
            "::",
            stringify!(DeviceTextType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LocaleId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9),
            "::",
            stringify!(LocaleId),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10 {
    pub InPath: BOOLEAN,
    pub Reserved: [BOOLEAN; 3usize],
    pub __bindgen_padding_0: u32,
    pub Type: DEVICE_USAGE_NOTIFICATION_TYPE,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10>(),
        16usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InPath) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10),
            "::",
            stringify!(InPath),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10),
            "::",
            stringify!(Reserved),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10),
            "::",
            stringify!(Type),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_21__bindgen_ty_10 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_21() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_21> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_21>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_21)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_21>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_21)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartDevice) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21),
            "::",
            stringify!(StartDevice),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).QueryDeviceRelations) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21),
            "::",
            stringify!(QueryDeviceRelations),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryInterface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21),
            "::",
            stringify!(QueryInterface),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DeviceCapabilities) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21),
            "::",
            stringify!(DeviceCapabilities),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FilterResourceRequirements) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21),
            "::",
            stringify!(FilterResourceRequirements),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadWriteConfig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21),
            "::",
            stringify!(ReadWriteConfig),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetLock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21),
            "::",
            stringify!(SetLock),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21),
            "::",
            stringify!(QueryId),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryDeviceText) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21),
            "::",
            stringify!(QueryDeviceText),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).UsageNotification) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_21),
            "::",
            stringify!(UsageNotification),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_21 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_22 {
    pub SyncType: FS_FILTER_SECTION_SYNC_TYPE,
    pub PageProtection: ULONG,
    pub OutputInformation: PFS_FILTER_SECTION_SYNC_OUTPUT,
    pub Flags: ULONG,
    pub AllocationAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_22() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_22> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_22>(),
        24usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_22)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_22>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_22)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SyncType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_22),
            "::",
            stringify!(SyncType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PageProtection) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_22),
            "::",
            stringify!(PageProtection),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OutputInformation) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_22),
            "::",
            stringify!(OutputInformation),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_22),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AllocationAttributes) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_22),
            "::",
            stringify!(AllocationAttributes),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_22 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_23 {
    pub EndingOffset: PLARGE_INTEGER,
    pub ResourceToRelease: *mut PERESOURCE,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_23() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_23> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_23>(),
        16usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_23)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_23>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_23)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndingOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_23),
            "::",
            stringify!(EndingOffset),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ResourceToRelease) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_23),
            "::",
            stringify!(ResourceToRelease),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_23 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_24 {
    pub ResourceToRelease: PERESOURCE,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_24() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_24> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_24>(),
        8usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_24)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_24>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_24)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ResourceToRelease) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_24),
            "::",
            stringify!(ResourceToRelease),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_24 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_25 {
    pub Irp: PIRP,
    pub FileInformation: PVOID,
    pub Length: PULONG,
    pub FileInformationClass: FILE_INFORMATION_CLASS,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_25() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_25> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_25>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_25)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_25>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_25)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Irp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_25),
            "::",
            stringify!(Irp),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileInformation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_25),
            "::",
            stringify!(FileInformation),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_25),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileInformationClass) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_25),
            "::",
            stringify!(FileInformationClass),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_25 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_26 {
    pub FileOffset: LARGE_INTEGER,
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub LockKey: ULONG,
    pub __bindgen_padding_1: [u8; 4usize],
    pub CheckForReadOperation: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_26() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_26> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_26>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_26)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_26>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_26)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_26),
            "::",
            stringify!(FileOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_26),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockKey) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_26),
            "::",
            stringify!(LockKey),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CheckForReadOperation) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_26),
            "::",
            stringify!(CheckForReadOperation),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_26 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_27 {
    pub Irp: PIRP,
    pub NetworkInformation: PFILE_NETWORK_OPEN_INFORMATION,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_27() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_27> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_27>(),
        16usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_27)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_27>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_27)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Irp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_27),
            "::",
            stringify!(Irp),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NetworkInformation) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_27),
            "::",
            stringify!(NetworkInformation),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_27 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_28 {
    pub FileOffset: LARGE_INTEGER,
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub MdlChain: *mut PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_28() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_28> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_28>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_28)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_28>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_28)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_28),
            "::",
            stringify!(FileOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_28),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_28),
            "::",
            stringify!(Key),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlChain) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_28),
            "::",
            stringify!(MdlChain),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_28 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_29 {
    pub MdlChain: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_29() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_29> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_29>(),
        8usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_29)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_29>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_29)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlChain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_29),
            "::",
            stringify!(MdlChain),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_29 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_30 {
    pub FileOffset: LARGE_INTEGER,
    pub Length: ULONG,
    pub __bindgen_padding_0: u32,
    pub Key: ULONG,
    pub MdlChain: *mut PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_30() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_30> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_30>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_30)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_30>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_30)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_30),
            "::",
            stringify!(FileOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_30),
            "::",
            stringify!(Length),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_30),
            "::",
            stringify!(Key),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlChain) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_30),
            "::",
            stringify!(MdlChain),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_30 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_31 {
    pub FileOffset: LARGE_INTEGER,
    pub MdlChain: PMDL,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_31() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_31> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_31>(),
        16usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_31)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_31>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_31)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_31),
            "::",
            stringify!(FileOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlChain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_31),
            "::",
            stringify!(MdlChain),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_31 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_32 {
    pub DeviceType: ULONG,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_32() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_32> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_32>(),
        4usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_32)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_32>(),
        4usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_32)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_32),
            "::",
            stringify!(DeviceType),
        ),
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_PARAMETERS__bindgen_ty_33 {
    pub Argument1: PVOID,
    pub Argument2: PVOID,
    pub Argument3: PVOID,
    pub Argument4: PVOID,
    pub Argument5: PVOID,
    pub Argument6: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS__bindgen_ty_33() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS__bindgen_ty_33> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS__bindgen_ty_33>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS__bindgen_ty_33)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS__bindgen_ty_33>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS__bindgen_ty_33)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Argument1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_33),
            "::",
            stringify!(Argument1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Argument2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_33),
            "::",
            stringify!(Argument2),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Argument3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_33),
            "::",
            stringify!(Argument3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Argument4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_33),
            "::",
            stringify!(Argument4),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Argument5) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_33),
            "::",
            stringify!(Argument5),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Argument6) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS__bindgen_ty_33),
            "::",
            stringify!(Argument6),
        ),
    );
}
impl Default for _FLT_PARAMETERS__bindgen_ty_33 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__FLT_PARAMETERS() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_PARAMETERS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_PARAMETERS>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_PARAMETERS)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_PARAMETERS)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Create) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(Create),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreatePipe) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(CreatePipe),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreateMailslot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(CreateMailslot),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Read) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_FLT_PARAMETERS), "::", stringify!(Read)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(Write),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).QueryFileInformation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(QueryFileInformation),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SetFileInformation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(SetFileInformation),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryEa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(QueryEa),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetEa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(SetEa),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).QueryVolumeInformation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(QueryVolumeInformation),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SetVolumeInformation) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(SetVolumeInformation),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DirectoryControl) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(DirectoryControl),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileSystemControl) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(FileSystemControl),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceIoControl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(DeviceIoControl),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockControl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(LockControl),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuerySecurity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(QuerySecurity),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetSecurity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(SetSecurity),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WMI) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_FLT_PARAMETERS), "::", stringify!(WMI)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryQuota) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(QueryQuota),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetQuota) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(SetQuota),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pnp) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_FLT_PARAMETERS), "::", stringify!(Pnp)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AcquireForSectionSynchronization) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(AcquireForSectionSynchronization),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AcquireForModifiedPageWriter) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(AcquireForModifiedPageWriter),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ReleaseForModifiedPageWriter) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(ReleaseForModifiedPageWriter),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueryOpen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(QueryOpen),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FastIoCheckIfPossible) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(FastIoCheckIfPossible),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NetworkQueryOpen) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(NetworkQueryOpen),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlRead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(MdlRead),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MdlReadComplete) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(MdlReadComplete),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrepareMdlWrite) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(PrepareMdlWrite),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).MdlWriteComplete) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(MdlWriteComplete),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MountVolume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(MountVolume),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Others) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_PARAMETERS),
            "::",
            stringify!(Others),
        ),
    );
}
impl Default for _FLT_PARAMETERS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_PARAMETERS = _FLT_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_IO_PARAMETER_BLOCK {
    pub IrpFlags: ULONG,
    pub MajorFunction: UCHAR,
    pub MinorFunction: UCHAR,
    pub OperationFlags: UCHAR,
    pub Reserved: UCHAR,
    pub TargetFileObject: PFILE_OBJECT,
    pub TargetInstance: PFLT_INSTANCE,
    pub Parameters: FLT_PARAMETERS,
}
#[test]
fn bindgen_test_layout__FLT_IO_PARAMETER_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_IO_PARAMETER_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_IO_PARAMETER_BLOCK>(),
        72usize,
        concat!("Size of: ", stringify!(_FLT_IO_PARAMETER_BLOCK)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_IO_PARAMETER_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_IO_PARAMETER_BLOCK)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IrpFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_IO_PARAMETER_BLOCK),
            "::",
            stringify!(IrpFlags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorFunction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_IO_PARAMETER_BLOCK),
            "::",
            stringify!(MajorFunction),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinorFunction) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_IO_PARAMETER_BLOCK),
            "::",
            stringify!(MinorFunction),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OperationFlags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_IO_PARAMETER_BLOCK),
            "::",
            stringify!(OperationFlags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_IO_PARAMETER_BLOCK),
            "::",
            stringify!(Reserved),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TargetFileObject) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_IO_PARAMETER_BLOCK),
            "::",
            stringify!(TargetFileObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TargetInstance) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_IO_PARAMETER_BLOCK),
            "::",
            stringify!(TargetInstance),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parameters) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_IO_PARAMETER_BLOCK),
            "::",
            stringify!(Parameters),
        ),
    );
}
impl Default for _FLT_IO_PARAMETER_BLOCK {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_IO_PARAMETER_BLOCK = _FLT_IO_PARAMETER_BLOCK;
pub type PFLT_IO_PARAMETER_BLOCK = *mut _FLT_IO_PARAMETER_BLOCK;
pub type FLT_CALLBACK_DATA_FLAGS = ULONG;
pub type FLT_ALLOCATE_CALLBACK_DATA_FLAGS = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_CALLBACK_DATA {
    pub Flags: FLT_CALLBACK_DATA_FLAGS,
    pub Thread: PETHREAD,
    pub Iopb: PFLT_IO_PARAMETER_BLOCK,
    pub IoStatus: IO_STATUS_BLOCK,
    pub TagData: *mut _FLT_TAG_DATA_BUFFER,
    pub __bindgen_anon_1: _FLT_CALLBACK_DATA__bindgen_ty_1,
    pub RequestorMode: KPROCESSOR_MODE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FLT_CALLBACK_DATA__bindgen_ty_1 {
    pub __bindgen_anon_1: _FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1,
    pub FilterContext: [PVOID; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1 {
    pub QueueLinks: LIST_ENTRY,
    pub QueueContext: [PVOID; 2usize],
}
#[test]
fn bindgen_test_layout__FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueueLinks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(QueueLinks),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueueContext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(QueueContext),
        ),
    );
}
impl Default for _FLT_CALLBACK_DATA__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__FLT_CALLBACK_DATA__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_CALLBACK_DATA__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_CALLBACK_DATA__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_CALLBACK_DATA__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_CALLBACK_DATA__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_CALLBACK_DATA__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FilterContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA__bindgen_ty_1),
            "::",
            stringify!(FilterContext),
        ),
    );
}
impl Default for _FLT_CALLBACK_DATA__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__FLT_CALLBACK_DATA() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_CALLBACK_DATA> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_CALLBACK_DATA>(),
        88usize,
        concat!("Size of: ", stringify!(_FLT_CALLBACK_DATA)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_CALLBACK_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_CALLBACK_DATA)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA),
            "::",
            stringify!(Thread),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Iopb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA),
            "::",
            stringify!(Iopb),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoStatus) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA),
            "::",
            stringify!(IoStatus),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TagData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA),
            "::",
            stringify!(TagData),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RequestorMode) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA),
            "::",
            stringify!(RequestorMode),
        ),
    );
}
impl Default for _FLT_CALLBACK_DATA {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_CALLBACK_DATA = _FLT_CALLBACK_DATA;
pub type PFLT_CALLBACK_DATA = *mut _FLT_CALLBACK_DATA;
extern "C" {
    pub fn FltSetCallbackDataDirty(Data: PFLT_CALLBACK_DATA);
}
extern "C" {
    pub fn FltClearCallbackDataDirty(Data: PFLT_CALLBACK_DATA);
}
extern "C" {
    pub fn FltIsCallbackDataDirty(Data: PFLT_CALLBACK_DATA) -> BOOLEAN;
}
pub type FLT_CONTEXT_TYPE = USHORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_RELATED_OBJECTS {
    pub Size: USHORT,
    pub TransactionContext: USHORT,
    pub Filter: PFLT_FILTER,
    pub Volume: PFLT_VOLUME,
    pub Instance: PFLT_INSTANCE,
    pub FileObject: PFILE_OBJECT,
    pub Transaction: PKTRANSACTION,
}
#[test]
fn bindgen_test_layout__FLT_RELATED_OBJECTS() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_RELATED_OBJECTS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_RELATED_OBJECTS>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_RELATED_OBJECTS)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_RELATED_OBJECTS>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_RELATED_OBJECTS)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_OBJECTS),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TransactionContext) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_OBJECTS),
            "::",
            stringify!(TransactionContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Filter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_OBJECTS),
            "::",
            stringify!(Filter),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Volume) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_OBJECTS),
            "::",
            stringify!(Volume),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_OBJECTS),
            "::",
            stringify!(Instance),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileObject) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_OBJECTS),
            "::",
            stringify!(FileObject),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Transaction) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_OBJECTS),
            "::",
            stringify!(Transaction),
        ),
    );
}
impl Default for _FLT_RELATED_OBJECTS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_RELATED_OBJECTS = _FLT_RELATED_OBJECTS;
pub type PCFLT_RELATED_OBJECTS = *const _FLT_RELATED_OBJECTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_RELATED_CONTEXTS {
    pub VolumeContext: PFLT_CONTEXT,
    pub InstanceContext: PFLT_CONTEXT,
    pub FileContext: PFLT_CONTEXT,
    pub StreamContext: PFLT_CONTEXT,
    pub StreamHandleContext: PFLT_CONTEXT,
    pub TransactionContext: PFLT_CONTEXT,
}
#[test]
fn bindgen_test_layout__FLT_RELATED_CONTEXTS() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_RELATED_CONTEXTS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_RELATED_CONTEXTS>(),
        48usize,
        concat!("Size of: ", stringify!(_FLT_RELATED_CONTEXTS)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_RELATED_CONTEXTS>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_RELATED_CONTEXTS)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS),
            "::",
            stringify!(VolumeContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InstanceContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS),
            "::",
            stringify!(InstanceContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileContext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS),
            "::",
            stringify!(FileContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamContext) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS),
            "::",
            stringify!(StreamContext),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).StreamHandleContext) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS),
            "::",
            stringify!(StreamHandleContext),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TransactionContext) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS),
            "::",
            stringify!(TransactionContext),
        ),
    );
}
impl Default for _FLT_RELATED_CONTEXTS {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_RELATED_CONTEXTS = _FLT_RELATED_CONTEXTS;
pub type PFLT_RELATED_CONTEXTS = *mut _FLT_RELATED_CONTEXTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_RELATED_CONTEXTS_EX {
    pub VolumeContext: PFLT_CONTEXT,
    pub InstanceContext: PFLT_CONTEXT,
    pub FileContext: PFLT_CONTEXT,
    pub StreamContext: PFLT_CONTEXT,
    pub StreamHandleContext: PFLT_CONTEXT,
    pub TransactionContext: PFLT_CONTEXT,
    pub SectionContext: PFLT_CONTEXT,
}
#[test]
fn bindgen_test_layout__FLT_RELATED_CONTEXTS_EX() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_RELATED_CONTEXTS_EX> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_RELATED_CONTEXTS_EX>(),
        56usize,
        concat!("Size of: ", stringify!(_FLT_RELATED_CONTEXTS_EX)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_RELATED_CONTEXTS_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_RELATED_CONTEXTS_EX)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS_EX),
            "::",
            stringify!(VolumeContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InstanceContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS_EX),
            "::",
            stringify!(InstanceContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileContext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS_EX),
            "::",
            stringify!(FileContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamContext) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS_EX),
            "::",
            stringify!(StreamContext),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).StreamHandleContext) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS_EX),
            "::",
            stringify!(StreamHandleContext),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TransactionContext) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS_EX),
            "::",
            stringify!(TransactionContext),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectionContext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_RELATED_CONTEXTS_EX),
            "::",
            stringify!(SectionContext),
        ),
    );
}
impl Default for _FLT_RELATED_CONTEXTS_EX {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_RELATED_CONTEXTS_EX = _FLT_RELATED_CONTEXTS_EX;
pub type PFLT_RELATED_CONTEXTS_EX = *mut _FLT_RELATED_CONTEXTS_EX;
pub type PFLT_CONTEXT_CLEANUP_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(Context: PFLT_CONTEXT, ContextType: FLT_CONTEXT_TYPE),
>;
pub type PFLT_CONTEXT_ALLOCATE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        PoolType: POOL_TYPE,
        Size: SIZE_T,
        ContextType: FLT_CONTEXT_TYPE,
    ) -> PVOID,
>;
pub type PFLT_CONTEXT_FREE_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(Pool: PVOID, ContextType: FLT_CONTEXT_TYPE),
>;
pub type FLT_CONTEXT_REGISTRATION_FLAGS = USHORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_CONTEXT_REGISTRATION {
    pub ContextType: FLT_CONTEXT_TYPE,
    pub Flags: FLT_CONTEXT_REGISTRATION_FLAGS,
    pub ContextCleanupCallback: PFLT_CONTEXT_CLEANUP_CALLBACK,
    pub Size: SIZE_T,
    pub PoolTag: ULONG,
    pub ContextAllocateCallback: PFLT_CONTEXT_ALLOCATE_CALLBACK,
    pub ContextFreeCallback: PFLT_CONTEXT_FREE_CALLBACK,
    pub Reserved1: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_CONTEXT_REGISTRATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_CONTEXT_REGISTRATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_CONTEXT_REGISTRATION>(),
        56usize,
        concat!("Size of: ", stringify!(_FLT_CONTEXT_REGISTRATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_CONTEXT_REGISTRATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_CONTEXT_REGISTRATION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContextType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CONTEXT_REGISTRATION),
            "::",
            stringify!(ContextType),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CONTEXT_REGISTRATION),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ContextCleanupCallback) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CONTEXT_REGISTRATION),
            "::",
            stringify!(ContextCleanupCallback),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CONTEXT_REGISTRATION),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PoolTag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CONTEXT_REGISTRATION),
            "::",
            stringify!(PoolTag),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ContextAllocateCallback) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CONTEXT_REGISTRATION),
            "::",
            stringify!(ContextAllocateCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ContextFreeCallback) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CONTEXT_REGISTRATION),
            "::",
            stringify!(ContextFreeCallback),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CONTEXT_REGISTRATION),
            "::",
            stringify!(Reserved1),
        ),
    );
}
impl Default for _FLT_CONTEXT_REGISTRATION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_CONTEXT_REGISTRATION = _FLT_CONTEXT_REGISTRATION;
pub type FLT_INSTANCE_SETUP_FLAGS = ULONG;
pub type PFLT_INSTANCE_SETUP_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        FltObjects: PCFLT_RELATED_OBJECTS,
        Flags: FLT_INSTANCE_SETUP_FLAGS,
        VolumeDeviceType: ULONG,
        VolumeFilesystemType: FLT_FILESYSTEM_TYPE,
    ) -> NTSTATUS,
>;
pub type FLT_INSTANCE_QUERY_TEARDOWN_FLAGS = ULONG;
pub type PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        FltObjects: PCFLT_RELATED_OBJECTS,
        Flags: FLT_INSTANCE_QUERY_TEARDOWN_FLAGS,
    ) -> NTSTATUS,
>;
pub type FLT_INSTANCE_TEARDOWN_FLAGS = ULONG;
pub type PFLT_INSTANCE_TEARDOWN_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        FltObjects: PCFLT_RELATED_OBJECTS,
        Reason: FLT_INSTANCE_TEARDOWN_FLAGS,
    ),
>;
pub mod _FLT_PREOP_CALLBACK_STATUS {
    pub type Type = ::core::ffi::c_int;
    pub const FLT_PREOP_SUCCESS_WITH_CALLBACK: Type = 0;
    pub const FLT_PREOP_SUCCESS_NO_CALLBACK: Type = 1;
    pub const FLT_PREOP_PENDING: Type = 2;
    pub const FLT_PREOP_DISALLOW_FASTIO: Type = 3;
    pub const FLT_PREOP_COMPLETE: Type = 4;
    pub const FLT_PREOP_SYNCHRONIZE: Type = 5;
    pub const FLT_PREOP_DISALLOW_FSFILTER_IO: Type = 6;
}
pub use self::_FLT_PREOP_CALLBACK_STATUS::Type as FLT_PREOP_CALLBACK_STATUS;
pub type PFLT_PRE_OPERATION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        Data: PFLT_CALLBACK_DATA,
        FltObjects: PCFLT_RELATED_OBJECTS,
        CompletionContext: *mut PVOID,
    ) -> FLT_PREOP_CALLBACK_STATUS,
>;
pub mod _FLT_POSTOP_CALLBACK_STATUS {
    pub type Type = ::core::ffi::c_int;
    pub const FLT_POSTOP_FINISHED_PROCESSING: Type = 0;
    pub const FLT_POSTOP_MORE_PROCESSING_REQUIRED: Type = 1;
    pub const FLT_POSTOP_DISALLOW_FSFILTER_IO: Type = 2;
}
pub use self::_FLT_POSTOP_CALLBACK_STATUS::Type as FLT_POSTOP_CALLBACK_STATUS;
pub type PFLT_POSTOP_CALLBACK_STATUS = *mut _FLT_POSTOP_CALLBACK_STATUS::Type;
pub type FLT_POST_OPERATION_FLAGS = ULONG;
pub type PFLT_POST_OPERATION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        Data: PFLT_CALLBACK_DATA,
        FltObjects: PCFLT_RELATED_OBJECTS,
        CompletionContext: PVOID,
        Flags: FLT_POST_OPERATION_FLAGS,
    ) -> FLT_POSTOP_CALLBACK_STATUS,
>;
extern "C" {
    pub fn FltDoCompletionProcessingWhenSafe(
        Data: PFLT_CALLBACK_DATA,
        FltObjects: PCFLT_RELATED_OBJECTS,
        CompletionContext: PVOID,
        Flags: FLT_POST_OPERATION_FLAGS,
        SafePostCallback: PFLT_POST_OPERATION_CALLBACK,
        RetPostOperationStatus: PFLT_POSTOP_CALLBACK_STATUS,
    ) -> BOOLEAN;
}
pub type FLT_OPERATION_REGISTRATION_FLAGS = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_OPERATION_REGISTRATION {
    pub MajorFunction: UCHAR,
    pub Flags: FLT_OPERATION_REGISTRATION_FLAGS,
    pub PreOperation: PFLT_PRE_OPERATION_CALLBACK,
    pub PostOperation: PFLT_POST_OPERATION_CALLBACK,
    pub Reserved1: PVOID,
}
#[test]
fn bindgen_test_layout__FLT_OPERATION_REGISTRATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_OPERATION_REGISTRATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_OPERATION_REGISTRATION>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_OPERATION_REGISTRATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_OPERATION_REGISTRATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_OPERATION_REGISTRATION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorFunction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_OPERATION_REGISTRATION),
            "::",
            stringify!(MajorFunction),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_OPERATION_REGISTRATION),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PreOperation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_OPERATION_REGISTRATION),
            "::",
            stringify!(PreOperation),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PostOperation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_OPERATION_REGISTRATION),
            "::",
            stringify!(PostOperation),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_OPERATION_REGISTRATION),
            "::",
            stringify!(Reserved1),
        ),
    );
}
impl Default for _FLT_OPERATION_REGISTRATION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_OPERATION_REGISTRATION = _FLT_OPERATION_REGISTRATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FLT_TAG_DATA_BUFFER {
    pub FileTag: ULONG,
    pub TagDataLength: USHORT,
    pub UnparsedNameLength: USHORT,
    pub __bindgen_anon_1: _FLT_TAG_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FLT_TAG_DATA_BUFFER__bindgen_ty_1 {
    pub SymbolicLinkReparseBuffer: _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1,
    pub MountPointReparseBuffer: _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2,
    pub GenericReparseBuffer: _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3,
    pub GenericGUIDReparseBuffer: _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1 {
    pub SubstituteNameOffset: USHORT,
    pub SubstituteNameLength: USHORT,
    pub PrintNameOffset: USHORT,
    pub PrintNameLength: USHORT,
    pub Flags: ULONG,
    pub PathBuffer: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SubstituteNameOffset) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SubstituteNameOffset),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SubstituteNameLength) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SubstituteNameLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrintNameOffset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(PrintNameOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrintNameLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(PrintNameLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PathBuffer) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(PathBuffer),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2 {
    pub SubstituteNameOffset: USHORT,
    pub SubstituteNameLength: USHORT,
    pub PrintNameOffset: USHORT,
    pub PrintNameLength: USHORT,
    pub PathBuffer: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2>(),
        10usize,
        concat!(
            "Size of: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SubstituteNameOffset) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(SubstituteNameOffset),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SubstituteNameLength) as usize - ptr as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(SubstituteNameLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrintNameOffset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(PrintNameOffset),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrintNameLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(PrintNameLength),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PathBuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(PathBuffer),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3 {
    pub DataBuffer: [UCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(DataBuffer),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4 {
    pub TagGuid: GUID,
    pub DataBuffer: [UCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<
        _FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4),
        ),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TagGuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(TagGuid),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(DataBuffer),
        ),
    );
}
#[test]
fn bindgen_test_layout__FLT_TAG_DATA_BUFFER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_TAG_DATA_BUFFER__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_TAG_DATA_BUFFER__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_TAG_DATA_BUFFER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1)),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SymbolicLinkReparseBuffer) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1),
            "::",
            stringify!(SymbolicLinkReparseBuffer),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).MountPointReparseBuffer) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1),
            "::",
            stringify!(MountPointReparseBuffer),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).GenericReparseBuffer) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1),
            "::",
            stringify!(GenericReparseBuffer),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).GenericGUIDReparseBuffer) as usize
                - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER__bindgen_ty_1),
            "::",
            stringify!(GenericGUIDReparseBuffer),
        ),
    );
}
impl Default for _FLT_TAG_DATA_BUFFER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__FLT_TAG_DATA_BUFFER() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_TAG_DATA_BUFFER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_TAG_DATA_BUFFER>(),
        28usize,
        concat!("Size of: ", stringify!(_FLT_TAG_DATA_BUFFER)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_TAG_DATA_BUFFER>(),
        4usize,
        concat!("Alignment of ", stringify!(_FLT_TAG_DATA_BUFFER)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileTag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER),
            "::",
            stringify!(FileTag),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TagDataLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER),
            "::",
            stringify!(TagDataLength),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).UnparsedNameLength) as usize - ptr as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_TAG_DATA_BUFFER),
            "::",
            stringify!(UnparsedNameLength),
        ),
    );
}
impl Default for _FLT_TAG_DATA_BUFFER {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_TAG_DATA_BUFFER = _FLT_TAG_DATA_BUFFER;
pub type FLT_FILTER_UNLOAD_FLAGS = ULONG;
pub type PFLT_FILTER_UNLOAD_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(Flags: FLT_FILTER_UNLOAD_FLAGS) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_NAME_CONTROL {
    pub Name: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__FLT_NAME_CONTROL() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_NAME_CONTROL> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_NAME_CONTROL>(),
        16usize,
        concat!("Size of: ", stringify!(_FLT_NAME_CONTROL)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_NAME_CONTROL>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_NAME_CONTROL)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_NAME_CONTROL),
            "::",
            stringify!(Name),
        ),
    );
}
impl Default for _FLT_NAME_CONTROL {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_NAME_CONTROL = _FLT_NAME_CONTROL;
pub type PFLT_NAME_CONTROL = *mut _FLT_NAME_CONTROL;
extern "C" {
    #[must_use]
    pub fn FltCheckAndGrowNameControl(
        NameCtrl: PFLT_NAME_CONTROL,
        NewSize: USHORT,
    ) -> NTSTATUS;
}
pub type FLT_FILE_NAME_OPTIONS = ULONG;
pub type PFLT_GENERATE_FILE_NAME = ::core::option::Option<
    unsafe extern "C" fn(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        CallbackData: PFLT_CALLBACK_DATA,
        NameOptions: FLT_FILE_NAME_OPTIONS,
        CacheFileNameInformation: PBOOLEAN,
        FileName: PFLT_NAME_CONTROL,
    ) -> NTSTATUS,
>;
pub type FLT_NORMALIZE_NAME_FLAGS = ULONG;
pub type PFLT_NORMALIZE_NAME_COMPONENT = ::core::option::Option<
    unsafe extern "C" fn(
        Instance: PFLT_INSTANCE,
        ParentDirectory: PCUNICODE_STRING,
        VolumeNameLength: USHORT,
        Component: PCUNICODE_STRING,
        ExpandComponentName: PFILE_NAMES_INFORMATION,
        ExpandComponentNameLength: ULONG,
        Flags: FLT_NORMALIZE_NAME_FLAGS,
        NormalizationContext: *mut PVOID,
    ) -> NTSTATUS,
>;
pub type PFLT_NORMALIZE_NAME_COMPONENT_EX = ::core::option::Option<
    unsafe extern "C" fn(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        ParentDirectory: PCUNICODE_STRING,
        VolumeNameLength: USHORT,
        Component: PCUNICODE_STRING,
        ExpandComponentName: PFILE_NAMES_INFORMATION,
        ExpandComponentNameLength: ULONG,
        Flags: FLT_NORMALIZE_NAME_FLAGS,
        NormalizationContext: *mut PVOID,
    ) -> NTSTATUS,
>;
pub type PFLT_NORMALIZE_CONTEXT_CLEANUP = ::core::option::Option<
    unsafe extern "C" fn(NormalizationContext: *mut PVOID),
>;
extern "C" {
    #[must_use]
    pub fn FltPurgeFileNameInformationCache(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
    ) -> NTSTATUS;
}
pub type PFLT_TRANSACTION_NOTIFICATION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        FltObjects: PCFLT_RELATED_OBJECTS,
        TransactionContext: PFLT_CONTEXT,
        NotificationMask: ULONG,
    ) -> NTSTATUS,
>;
pub type PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        Instance: PFLT_INSTANCE,
        SectionContext: PFLT_CONTEXT,
        Data: PFLT_CALLBACK_DATA,
    ) -> NTSTATUS,
>;
extern "C" {
    #[must_use]
    pub fn FltRegisterForDataScan(Instance: PFLT_INSTANCE) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltCreateSectionForDataScan(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        SectionContext: PFLT_CONTEXT,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        MaximumSize: PLARGE_INTEGER,
        SectionPageProtection: ULONG,
        AllocationAttributes: ULONG,
        Flags: ULONG,
        SectionHandle: PHANDLE,
        SectionObject: *mut PVOID,
        SectionFileSize: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltCloseSectionForDataScan(SectionContext: PFLT_CONTEXT) -> NTSTATUS;
}
pub type FLT_REGISTRATION_FLAGS = ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_REGISTRATION {
    pub Size: USHORT,
    pub Version: USHORT,
    pub Flags: FLT_REGISTRATION_FLAGS,
    pub ContextRegistration: *const FLT_CONTEXT_REGISTRATION,
    pub OperationRegistration: *const FLT_OPERATION_REGISTRATION,
    pub FilterUnloadCallback: PFLT_FILTER_UNLOAD_CALLBACK,
    pub InstanceSetupCallback: PFLT_INSTANCE_SETUP_CALLBACK,
    pub InstanceQueryTeardownCallback: PFLT_INSTANCE_QUERY_TEARDOWN_CALLBACK,
    pub InstanceTeardownStartCallback: PFLT_INSTANCE_TEARDOWN_CALLBACK,
    pub InstanceTeardownCompleteCallback: PFLT_INSTANCE_TEARDOWN_CALLBACK,
    pub GenerateFileNameCallback: PFLT_GENERATE_FILE_NAME,
    pub NormalizeNameComponentCallback: PFLT_NORMALIZE_NAME_COMPONENT,
    pub NormalizeContextCleanupCallback: PFLT_NORMALIZE_CONTEXT_CLEANUP,
    pub TransactionNotificationCallback: PFLT_TRANSACTION_NOTIFICATION_CALLBACK,
    pub NormalizeNameComponentExCallback: PFLT_NORMALIZE_NAME_COMPONENT_EX,
    pub SectionNotificationCallback: PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK,
}
#[test]
fn bindgen_test_layout__FLT_REGISTRATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_REGISTRATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_REGISTRATION>(),
        112usize,
        concat!("Size of: ", stringify!(_FLT_REGISTRATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_REGISTRATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_REGISTRATION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(Version),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ContextRegistration) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(ContextRegistration),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).OperationRegistration) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(OperationRegistration),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FilterUnloadCallback) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(FilterUnloadCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InstanceSetupCallback) as usize - ptr as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(InstanceSetupCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InstanceQueryTeardownCallback) as usize
                - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(InstanceQueryTeardownCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InstanceTeardownStartCallback) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(InstanceTeardownStartCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).InstanceTeardownCompleteCallback) as usize
                - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(InstanceTeardownCompleteCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).GenerateFileNameCallback) as usize
                - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(GenerateFileNameCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NormalizeNameComponentCallback) as usize
                - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(NormalizeNameComponentCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NormalizeContextCleanupCallback) as usize
                - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(NormalizeContextCleanupCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).TransactionNotificationCallback) as usize
                - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(TransactionNotificationCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).NormalizeNameComponentExCallback) as usize
                - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(NormalizeNameComponentExCallback),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).SectionNotificationCallback) as usize
                - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_REGISTRATION),
            "::",
            stringify!(SectionNotificationCallback),
        ),
    );
}
impl Default for _FLT_REGISTRATION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_REGISTRATION = _FLT_REGISTRATION;
pub type PFLT_COMPLETED_ASYNC_IO_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(CallbackData: PFLT_CALLBACK_DATA, Context: PFLT_CONTEXT),
>;
pub type FLT_IO_OPERATION_FLAGS = ULONG;
extern "C" {
    #[must_use]
    pub fn FltRegisterFilter(
        Driver: PDRIVER_OBJECT,
        Registration: *const FLT_REGISTRATION,
        RetFilter: *mut PFLT_FILTER,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltUnregisterFilter(Filter: PFLT_FILTER);
}
extern "C" {
    #[must_use]
    pub fn FltStartFiltering(Filter: PFLT_FILTER) -> NTSTATUS;
}
extern "C" {
    pub fn FltGetRoutineAddress(FltMgrRoutineName: PCSTR) -> PVOID;
}
extern "C" {
    pub fn FltCompletePendedPreOperation(
        CallbackData: PFLT_CALLBACK_DATA,
        CallbackStatus: FLT_PREOP_CALLBACK_STATUS,
        Context: PVOID,
    );
}
extern "C" {
    pub fn FltCompletePendedPostOperation(CallbackData: PFLT_CALLBACK_DATA);
}
pub type PFLT_GET_OPERATION_STATUS_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(
        FltObjects: PCFLT_RELATED_OBJECTS,
        IopbSnapshot: PFLT_IO_PARAMETER_BLOCK,
        OperationStatus: NTSTATUS,
        RequesterContext: PVOID,
    ),
>;
extern "C" {
    #[must_use]
    pub fn FltRequestOperationStatusCallback(
        Data: PFLT_CALLBACK_DATA,
        CallbackRoutine: PFLT_GET_OPERATION_STATUS_CALLBACK,
        RequesterContext: PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltAllocatePoolAlignedWithTag(
        Instance: PFLT_INSTANCE,
        PoolType: POOL_TYPE,
        NumberOfBytes: SIZE_T,
        Tag: ULONG,
    ) -> PVOID;
}
extern "C" {
    pub fn FltFreePoolAlignedWithTag(Instance: PFLT_INSTANCE, Buffer: PVOID, Tag: ULONG);
}
pub type FLT_FILE_NAME_PARSED_FLAGS = USHORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_FILE_NAME_INFORMATION {
    pub Size: USHORT,
    pub NamesParsed: FLT_FILE_NAME_PARSED_FLAGS,
    pub Format: FLT_FILE_NAME_OPTIONS,
    pub Name: UNICODE_STRING,
    pub Volume: UNICODE_STRING,
    pub Share: UNICODE_STRING,
    pub Extension: UNICODE_STRING,
    pub Stream: UNICODE_STRING,
    pub FinalComponent: UNICODE_STRING,
    pub ParentDir: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__FLT_FILE_NAME_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_FILE_NAME_INFORMATION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_FILE_NAME_INFORMATION>(),
        120usize,
        concat!("Size of: ", stringify!(_FLT_FILE_NAME_INFORMATION)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_FILE_NAME_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_FILE_NAME_INFORMATION)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_FILE_NAME_INFORMATION),
            "::",
            stringify!(Size),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamesParsed) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_FILE_NAME_INFORMATION),
            "::",
            stringify!(NamesParsed),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_FILE_NAME_INFORMATION),
            "::",
            stringify!(Format),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_FILE_NAME_INFORMATION),
            "::",
            stringify!(Name),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Volume) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_FILE_NAME_INFORMATION),
            "::",
            stringify!(Volume),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Share) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_FILE_NAME_INFORMATION),
            "::",
            stringify!(Share),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Extension) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_FILE_NAME_INFORMATION),
            "::",
            stringify!(Extension),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Stream) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_FILE_NAME_INFORMATION),
            "::",
            stringify!(Stream),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinalComponent) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_FILE_NAME_INFORMATION),
            "::",
            stringify!(FinalComponent),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ParentDir) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_FILE_NAME_INFORMATION),
            "::",
            stringify!(ParentDir),
        ),
    );
}
impl Default for _FLT_FILE_NAME_INFORMATION {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_FILE_NAME_INFORMATION = _FLT_FILE_NAME_INFORMATION;
pub type PFLT_FILE_NAME_INFORMATION = *mut _FLT_FILE_NAME_INFORMATION;
extern "C" {
    #[must_use]
    pub fn FltGetFileNameInformation(
        CallbackData: PFLT_CALLBACK_DATA,
        NameOptions: FLT_FILE_NAME_OPTIONS,
        FileNameInformation: *mut PFLT_FILE_NAME_INFORMATION,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetFileNameInformationUnsafe(
        FileObject: PFILE_OBJECT,
        Instance: PFLT_INSTANCE,
        NameOptions: FLT_FILE_NAME_OPTIONS,
        FileNameInformation: *mut PFLT_FILE_NAME_INFORMATION,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltReleaseFileNameInformation(
        FileNameInformation: PFLT_FILE_NAME_INFORMATION,
    );
}
extern "C" {
    pub fn FltReferenceFileNameInformation(
        FileNameInformation: PFLT_FILE_NAME_INFORMATION,
    );
}
extern "C" {
    #[must_use]
    pub fn FltParseFileName(
        FileName: PCUNICODE_STRING,
        Extension: PUNICODE_STRING,
        Stream: PUNICODE_STRING,
        FinalComponent: PUNICODE_STRING,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltParseFileNameInformation(
        FileNameInformation: PFLT_FILE_NAME_INFORMATION,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetTunneledName(
        CallbackData: PFLT_CALLBACK_DATA,
        FileNameInformation: PFLT_FILE_NAME_INFORMATION,
        RetTunneledFileNameInformation: *mut PFLT_FILE_NAME_INFORMATION,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetVolumeName(
        Volume: PFLT_VOLUME,
        VolumeName: PUNICODE_STRING,
        BufferSizeNeeded: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetDestinationFileNameInformation(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        RootDirectory: HANDLE,
        FileName: PWSTR,
        FileNameLength: ULONG,
        NameOptions: FLT_FILE_NAME_OPTIONS,
        RetFileNameInformation: *mut PFLT_FILE_NAME_INFORMATION,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltIsDirectory(
        FileObject: PFILE_OBJECT,
        Instance: PFLT_INSTANCE,
        IsDirectory: PBOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltLoadFilter(FilterName: PCUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltUnloadFilter(FilterName: PCUNICODE_STRING) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltAttachVolume(
        Filter: PFLT_FILTER,
        Volume: PFLT_VOLUME,
        InstanceName: PCUNICODE_STRING,
        RetInstance: *mut PFLT_INSTANCE,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltAttachVolumeAtAltitude(
        Filter: PFLT_FILTER,
        Volume: PFLT_VOLUME,
        Altitude: PCUNICODE_STRING,
        InstanceName: PCUNICODE_STRING,
        RetInstance: *mut PFLT_INSTANCE,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltDetachVolume(
        Filter: PFLT_FILTER,
        Volume: PFLT_VOLUME,
        InstanceName: PCUNICODE_STRING,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltAllocateCallbackData(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        RetNewCallbackData: *mut PFLT_CALLBACK_DATA,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltAllocateCallbackDataEx(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        Flags: FLT_ALLOCATE_CALLBACK_DATA_FLAGS,
        RetNewCallbackData: *mut PFLT_CALLBACK_DATA,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltFreeCallbackData(CallbackData: PFLT_CALLBACK_DATA);
}
extern "C" {
    pub fn FltReuseCallbackData(CallbackData: PFLT_CALLBACK_DATA);
}
extern "C" {
    pub fn FltPerformSynchronousIo(CallbackData: PFLT_CALLBACK_DATA);
}
extern "C" {
    #[must_use]
    pub fn FltPerformAsynchronousIo(
        CallbackData: PFLT_CALLBACK_DATA,
        CallbackRoutine: PFLT_COMPLETED_ASYNC_IO_CALLBACK,
        CallbackContext: PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltpTraceRedirectedFileIo(
        OriginatingFileObject: PFILE_OBJECT,
        ChildCallbackData: PFLT_CALLBACK_DATA,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltCreateNamedPipeFile(
        Filter: PFLT_FILTER,
        Instance: PFLT_INSTANCE,
        FileHandle: PHANDLE,
        FileObject: *mut PFILE_OBJECT,
        DesiredAccess: ULONG,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
        NamedPipeType: ULONG,
        ReadMode: ULONG,
        CompletionMode: ULONG,
        MaximumInstances: ULONG,
        InboundQuota: ULONG,
        OutboundQuota: ULONG,
        DefaultTimeout: PLARGE_INTEGER,
        DriverContext: PIO_DRIVER_CREATE_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltCreateMailslotFile(
        Filter: PFLT_FILTER,
        Instance: PFLT_INSTANCE,
        FileHandle: PHANDLE,
        FileObject: *mut PFILE_OBJECT,
        DesiredAccess: ULONG,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        CreateOptions: ULONG,
        MailslotQuota: ULONG,
        MaximumMessageSize: ULONG,
        ReadTimeout: PLARGE_INTEGER,
        DriverContext: PIO_DRIVER_CREATE_CONTEXT,
    ) -> NTSTATUS;
}
pub type FLT_CREATEFILE_TARGET_FLAGS = USHORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_CREATEFILE_TARGET_ECP_CONTEXT {
    pub Instance: PFLT_INSTANCE,
    pub Volume: PFLT_VOLUME,
    pub FileNameInformation: PFLT_FILE_NAME_INFORMATION,
    pub Flags: FLT_CREATEFILE_TARGET_FLAGS,
}
#[test]
fn bindgen_test_layout__FLT_CREATEFILE_TARGET_ECP_CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_CREATEFILE_TARGET_ECP_CONTEXT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_CREATEFILE_TARGET_ECP_CONTEXT>(),
        32usize,
        concat!("Size of: ", stringify!(_FLT_CREATEFILE_TARGET_ECP_CONTEXT)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_CREATEFILE_TARGET_ECP_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_CREATEFILE_TARGET_ECP_CONTEXT)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CREATEFILE_TARGET_ECP_CONTEXT),
            "::",
            stringify!(Instance),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Volume) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CREATEFILE_TARGET_ECP_CONTEXT),
            "::",
            stringify!(Volume),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileNameInformation) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CREATEFILE_TARGET_ECP_CONTEXT),
            "::",
            stringify!(FileNameInformation),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CREATEFILE_TARGET_ECP_CONTEXT),
            "::",
            stringify!(Flags),
        ),
    );
}
impl Default for _FLT_CREATEFILE_TARGET_ECP_CONTEXT {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_CREATEFILE_TARGET_ECP_CONTEXT = _FLT_CREATEFILE_TARGET_ECP_CONTEXT;
extern "C" {
    #[must_use]
    pub fn FltCreateFileEx2(
        Filter: PFLT_FILTER,
        Instance: PFLT_INSTANCE,
        FileHandle: PHANDLE,
        FileObject: *mut PFILE_OBJECT,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
        Flags: ULONG,
        DriverContext: PIO_DRIVER_CREATE_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltCreateFileEx(
        Filter: PFLT_FILTER,
        Instance: PFLT_INSTANCE,
        FileHandle: PHANDLE,
        FileObject: *mut PFILE_OBJECT,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
        Flags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltCreateFile(
        Filter: PFLT_FILTER,
        Instance: PFLT_INSTANCE,
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
        EaBuffer: PVOID,
        EaLength: ULONG,
        Flags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltOpenVolume(
        Instance: PFLT_INSTANCE,
        VolumeHandle: PHANDLE,
        VolumeFileObject: *mut PFILE_OBJECT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltReadFile(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        ByteOffset: PLARGE_INTEGER,
        Length: ULONG,
        Buffer: PVOID,
        Flags: FLT_IO_OPERATION_FLAGS,
        BytesRead: PULONG,
        CallbackRoutine: PFLT_COMPLETED_ASYNC_IO_CALLBACK,
        CallbackContext: PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltReadFileEx(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        ByteOffset: PLARGE_INTEGER,
        Length: ULONG,
        Buffer: PVOID,
        Flags: FLT_IO_OPERATION_FLAGS,
        BytesRead: PULONG,
        CallbackRoutine: PFLT_COMPLETED_ASYNC_IO_CALLBACK,
        CallbackContext: PVOID,
        Key: PULONG,
        Mdl: PMDL,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltTagFile(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FileTag: ULONG,
        Guid: *mut GUID,
        DataBuffer: PVOID,
        DataBufferLength: USHORT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltTagFileEx(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FileTag: ULONG,
        Guid: *mut GUID,
        DataBuffer: PVOID,
        DataBufferLength: USHORT,
        ExistingFileTag: ULONG,
        ExistingGuid: *mut GUID,
        Flags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltUntagFile(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FileTag: ULONG,
        Guid: *mut GUID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltWriteFile(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        ByteOffset: PLARGE_INTEGER,
        Length: ULONG,
        Buffer: PVOID,
        Flags: FLT_IO_OPERATION_FLAGS,
        BytesWritten: PULONG,
        CallbackRoutine: PFLT_COMPLETED_ASYNC_IO_CALLBACK,
        CallbackContext: PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltWriteFileEx(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        ByteOffset: PLARGE_INTEGER,
        Length: ULONG,
        Buffer: PVOID,
        Flags: FLT_IO_OPERATION_FLAGS,
        BytesWritten: PULONG,
        CallbackRoutine: PFLT_COMPLETED_ASYNC_IO_CALLBACK,
        CallbackContext: PVOID,
        Key: PULONG,
        Mdl: PMDL,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltFastIoMdlRead(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FltFastIoMdlReadComplete(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        MdlChain: PMDL,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FltFastIoPrepareMdlWrite(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        Length: ULONG,
        LockKey: ULONG,
        MdlChain: *mut PMDL,
        IoStatus: PIO_STATUS_BLOCK,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FltFastIoMdlWriteComplete(
        InitiatingInstance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FileOffset: PLARGE_INTEGER,
        MdlChain: PMDL,
    ) -> BOOLEAN;
}
extern "C" {
    #[must_use]
    pub fn FltQueryInformationByName(
        Filter: PFLT_FILTER,
        Instance: PFLT_INSTANCE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        DriverContext: PIO_DRIVER_CREATE_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltQueryInformationFile(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        LengthReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetInformationFile(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltQueryDirectoryFile(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        ReturnSingleEntry: BOOLEAN,
        FileName: PUNICODE_STRING,
        RestartScan: BOOLEAN,
        LengthReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltQueryDirectoryFileEx(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        QueryFlags: ULONG,
        FileName: PUNICODE_STRING,
        LengthReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltQueryQuotaInformationFile(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ReturnSingleEntry: BOOLEAN,
        SidList: PVOID,
        SidListLength: ULONG,
        StartSid: PULONG,
        RestartScan: BOOLEAN,
        LengthReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetQuotaInformationFile(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltQueryEaFile(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        ReturnedEaData: PVOID,
        Length: ULONG,
        ReturnSingleEntry: BOOLEAN,
        EaList: PVOID,
        EaListLength: ULONG,
        EaIndex: PULONG,
        RestartScan: BOOLEAN,
        LengthReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetEaFile(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        EaBuffer: PVOID,
        Length: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltQueryVolumeInformationFile(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FsInformation: PVOID,
        Length: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
        LengthReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltQuerySecurityObject(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        SecurityInformation: SECURITY_INFORMATION,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        Length: ULONG,
        LengthNeeded: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetSecurityObject(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        SecurityInformation: SECURITY_INFORMATION,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltFlushBuffers(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltFlushBuffers2(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FlushType: ULONG,
        CallbackData: PFLT_CALLBACK_DATA,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltFsControlFile(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        FsControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        LengthReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltDeviceIoControlFile(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        IoControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        LengthReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltReissueSynchronousIo(
        InitiatingInstance: PFLT_INSTANCE,
        CallbackData: PFLT_CALLBACK_DATA,
    );
}
extern "C" {
    #[must_use]
    pub fn FltClose(FileHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn FltCancelFileOpen(Instance: PFLT_INSTANCE, FileObject: PFILE_OBJECT);
}
extern "C" {
    #[must_use]
    pub fn FltCreateSystemVolumeInformationFolder(Instance: PFLT_INSTANCE) -> NTSTATUS;
}
extern "C" {
    pub fn FltSupportsFileContextsEx(
        FileObject: PFILE_OBJECT,
        Instance: PFLT_INSTANCE,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FltSupportsFileContexts(FileObject: PFILE_OBJECT) -> BOOLEAN;
}
extern "C" {
    pub fn FltSupportsStreamContexts(FileObject: PFILE_OBJECT) -> BOOLEAN;
}
extern "C" {
    pub fn FltSupportsStreamHandleContexts(FileObject: PFILE_OBJECT) -> BOOLEAN;
}
extern "C" {
    #[must_use]
    pub fn FltAllocateContext(
        Filter: PFLT_FILTER,
        ContextType: FLT_CONTEXT_TYPE,
        ContextSize: SIZE_T,
        PoolType: POOL_TYPE,
        ReturnedContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltGetContexts(
        FltObjects: PCFLT_RELATED_OBJECTS,
        DesiredContexts: FLT_CONTEXT_TYPE,
        Contexts: PFLT_RELATED_CONTEXTS,
    );
}
extern "C" {
    pub fn FltReleaseContexts(Contexts: PFLT_RELATED_CONTEXTS);
}
extern "C" {
    #[must_use]
    pub fn FltGetContextsEx(
        FltObjects: PCFLT_RELATED_OBJECTS,
        DesiredContexts: FLT_CONTEXT_TYPE,
        ContextsSize: SIZE_T,
        Contexts: PFLT_RELATED_CONTEXTS_EX,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltReleaseContextsEx(
        ContextsSize: SIZE_T,
        Contexts: PFLT_RELATED_CONTEXTS_EX,
    );
}
pub mod _FLT_SET_CONTEXT_OPERATION {
    pub type Type = ::core::ffi::c_int;
    pub const FLT_SET_CONTEXT_REPLACE_IF_EXISTS: Type = 0;
    pub const FLT_SET_CONTEXT_KEEP_IF_EXISTS: Type = 1;
}
pub use self::_FLT_SET_CONTEXT_OPERATION::Type as FLT_SET_CONTEXT_OPERATION;
extern "C" {
    #[must_use]
    pub fn FltSetVolumeContext(
        Volume: PFLT_VOLUME,
        Operation: FLT_SET_CONTEXT_OPERATION,
        NewContext: PFLT_CONTEXT,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetInstanceContext(
        Instance: PFLT_INSTANCE,
        Operation: FLT_SET_CONTEXT_OPERATION,
        NewContext: PFLT_CONTEXT,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetFileContext(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        Operation: FLT_SET_CONTEXT_OPERATION,
        NewContext: PFLT_CONTEXT,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetStreamContext(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        Operation: FLT_SET_CONTEXT_OPERATION,
        NewContext: PFLT_CONTEXT,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetStreamHandleContext(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        Operation: FLT_SET_CONTEXT_OPERATION,
        NewContext: PFLT_CONTEXT,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetTransactionContext(
        Instance: PFLT_INSTANCE,
        Transaction: PKTRANSACTION,
        Operation: FLT_SET_CONTEXT_OPERATION,
        NewContext: PFLT_CONTEXT,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltDeleteContext(Context: PFLT_CONTEXT);
}
extern "C" {
    #[must_use]
    pub fn FltDeleteVolumeContext(
        Filter: PFLT_FILTER,
        Volume: PFLT_VOLUME,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltDeleteInstanceContext(
        Instance: PFLT_INSTANCE,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltDeleteFileContext(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltDeleteStreamContext(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltDeleteStreamHandleContext(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltDeleteTransactionContext(
        Instance: PFLT_INSTANCE,
        Transaction: PKTRANSACTION,
        OldContext: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetVolumeContext(
        Filter: PFLT_FILTER,
        Volume: PFLT_VOLUME,
        Context: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetInstanceContext(
        Instance: PFLT_INSTANCE,
        Context: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetFileContext(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        Context: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetStreamContext(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        Context: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetStreamHandleContext(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        Context: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetTransactionContext(
        Instance: PFLT_INSTANCE,
        Transaction: PKTRANSACTION,
        Context: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetSectionContext(
        Instance: PFLT_INSTANCE,
        FileObject: PFILE_OBJECT,
        Context: *mut PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltReferenceContext(Context: PFLT_CONTEXT);
}
extern "C" {
    pub fn FltReleaseContext(Context: PFLT_CONTEXT);
}
extern "C" {
    #[must_use]
    pub fn FltGetFilterFromName(
        FilterName: PCUNICODE_STRING,
        RetFilter: *mut PFLT_FILTER,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetVolumeFromName(
        Filter: PFLT_FILTER,
        VolumeName: PCUNICODE_STRING,
        RetVolume: *mut PFLT_VOLUME,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetVolumeInstanceFromName(
        Filter: PFLT_FILTER,
        Volume: PFLT_VOLUME,
        InstanceName: PCUNICODE_STRING,
        RetInstance: *mut PFLT_INSTANCE,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetVolumeFromInstance(
        Instance: PFLT_INSTANCE,
        RetVolume: *mut PFLT_VOLUME,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetFilterFromInstance(
        Instance: PFLT_INSTANCE,
        RetFilter: *mut PFLT_FILTER,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetVolumeFromFileObject(
        Filter: PFLT_FILTER,
        FileObject: PFILE_OBJECT,
        RetVolume: *mut PFLT_VOLUME,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetVolumeFromDeviceObject(
        Filter: PFLT_FILTER,
        DeviceObject: PDEVICE_OBJECT,
        RetVolume: *mut PFLT_VOLUME,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltIsFltMgrVolumeDeviceObject(DeviceObject: PDEVICE_OBJECT) -> BOOLEAN;
}
extern "C" {
    #[must_use]
    pub fn FltGetDeviceObject(
        Volume: PFLT_VOLUME,
        DeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetDiskDeviceObject(
        Volume: PFLT_VOLUME,
        DiskDeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetLowerInstance(
        CurrentInstance: PFLT_INSTANCE,
        LowerInstance: *mut PFLT_INSTANCE,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetUpperInstance(
        CurrentInstance: PFLT_INSTANCE,
        UpperInstance: *mut PFLT_INSTANCE,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetTopInstance(
        Volume: PFLT_VOLUME,
        Instance: *mut PFLT_INSTANCE,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetBottomInstance(
        Volume: PFLT_VOLUME,
        Instance: *mut PFLT_INSTANCE,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltCompareInstanceAltitudes(
        Instance1: PFLT_INSTANCE,
        Instance2: PFLT_INSTANCE,
    ) -> LONG;
}
extern "C" {
    #[must_use]
    pub fn FltGetFilterInformation(
        Filter: PFLT_FILTER,
        InformationClass: FILTER_INFORMATION_CLASS,
        Buffer: PVOID,
        BufferSize: ULONG,
        BytesReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetInstanceInformation(
        Instance: PFLT_INSTANCE,
        InformationClass: INSTANCE_INFORMATION_CLASS,
        Buffer: PVOID,
        BufferSize: ULONG,
        BytesReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetVolumeInformation(
        Volume: PFLT_VOLUME,
        InformationClass: FILTER_VOLUME_INFORMATION_CLASS,
        Buffer: PVOID,
        BufferSize: ULONG,
        BytesReturned: PULONG,
    ) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_VOLUME_PROPERTIES {
    pub DeviceType: ULONG,
    pub DeviceCharacteristics: ULONG,
    pub DeviceObjectFlags: ULONG,
    pub AlignmentRequirement: ULONG,
    pub SectorSize: USHORT,
    pub Flags: USHORT,
    pub FileSystemDriverName: UNICODE_STRING,
    pub FileSystemDeviceName: UNICODE_STRING,
    pub RealDeviceName: UNICODE_STRING,
}
#[test]
fn bindgen_test_layout__FLT_VOLUME_PROPERTIES() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_VOLUME_PROPERTIES> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_VOLUME_PROPERTIES>(),
        72usize,
        concat!("Size of: ", stringify!(_FLT_VOLUME_PROPERTIES)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_VOLUME_PROPERTIES>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_VOLUME_PROPERTIES)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_VOLUME_PROPERTIES),
            "::",
            stringify!(DeviceType),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DeviceCharacteristics) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_VOLUME_PROPERTIES),
            "::",
            stringify!(DeviceCharacteristics),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).DeviceObjectFlags) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_VOLUME_PROPERTIES),
            "::",
            stringify!(DeviceObjectFlags),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).AlignmentRequirement) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_VOLUME_PROPERTIES),
            "::",
            stringify!(AlignmentRequirement),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_VOLUME_PROPERTIES),
            "::",
            stringify!(SectorSize),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_VOLUME_PROPERTIES),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileSystemDriverName) as usize - ptr as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_VOLUME_PROPERTIES),
            "::",
            stringify!(FileSystemDriverName),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).FileSystemDeviceName) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_VOLUME_PROPERTIES),
            "::",
            stringify!(FileSystemDeviceName),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RealDeviceName) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_VOLUME_PROPERTIES),
            "::",
            stringify!(RealDeviceName),
        ),
    );
}
impl Default for _FLT_VOLUME_PROPERTIES {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FLT_VOLUME_PROPERTIES = _FLT_VOLUME_PROPERTIES;
pub type PFLT_VOLUME_PROPERTIES = *mut _FLT_VOLUME_PROPERTIES;
extern "C" {
    #[must_use]
    pub fn FltGetVolumeProperties(
        Volume: PFLT_VOLUME,
        VolumeProperties: PFLT_VOLUME_PROPERTIES,
        VolumePropertiesLength: ULONG,
        LengthReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltIsVolumeWritable(FltObject: PVOID, IsWritable: PBOOLEAN) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetFileSystemType(
        FltObject: PVOID,
        FileSystemType: PFLT_FILESYSTEM_TYPE,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltIsVolumeSnapshot(FltObject: PVOID, IsSnapshotVolume: PBOOLEAN) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetVolumeGuidName(
        Volume: PFLT_VOLUME,
        VolumeGuidName: PUNICODE_STRING,
        BufferSizeNeeded: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltQueryVolumeInformation(
        Instance: PFLT_INSTANCE,
        Iosb: PIO_STATUS_BLOCK,
        FsInformation: PVOID,
        Length: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetVolumeInformation(
        Instance: PFLT_INSTANCE,
        Iosb: PIO_STATUS_BLOCK,
        FsInformation: PVOID,
        Length: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltEnumerateFilters(
        FilterList: *mut PFLT_FILTER,
        FilterListSize: ULONG,
        NumberFiltersReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltEnumerateVolumes(
        Filter: PFLT_FILTER,
        VolumeList: *mut PFLT_VOLUME,
        VolumeListSize: ULONG,
        NumberVolumesReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltEnumerateInstances(
        Volume: PFLT_VOLUME,
        Filter: PFLT_FILTER,
        InstanceList: *mut PFLT_INSTANCE,
        InstanceListSize: ULONG,
        NumberInstancesReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltEnumerateFilterInformation(
        Index: ULONG,
        InformationClass: FILTER_INFORMATION_CLASS,
        Buffer: PVOID,
        BufferSize: ULONG,
        BytesReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltEnumerateInstanceInformationByFilter(
        Filter: PFLT_FILTER,
        Index: ULONG,
        InformationClass: INSTANCE_INFORMATION_CLASS,
        Buffer: PVOID,
        BufferSize: ULONG,
        BytesReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltEnumerateInstanceInformationByVolume(
        Volume: PFLT_VOLUME,
        Index: ULONG,
        InformationClass: INSTANCE_INFORMATION_CLASS,
        Buffer: PVOID,
        BufferSize: ULONG,
        BytesReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltEnumerateInstanceInformationByVolumeName(
        VolumeName: PUNICODE_STRING,
        Index: ULONG,
        InformationClass: INSTANCE_INFORMATION_CLASS,
        Buffer: PVOID,
        BufferSize: ULONG,
        BytesReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltEnumerateInstanceInformationByDeviceObject(
        DeviceObject: PDEVICE_OBJECT,
        Index: ULONG,
        InformationClass: INSTANCE_INFORMATION_CLASS,
        Buffer: PVOID,
        BufferSize: ULONG,
        BytesReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltEnumerateVolumeInformation(
        Filter: PFLT_FILTER,
        Index: ULONG,
        InformationClass: FILTER_VOLUME_INFORMATION_CLASS,
        Buffer: PVOID,
        BufferSize: ULONG,
        BytesReturned: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltObjectReference(FltObject: PVOID) -> NTSTATUS;
}
extern "C" {
    pub fn FltObjectDereference(FltObject: PVOID);
}
pub type PFLT_MESSAGE_NOTIFY = ::core::option::Option<
    unsafe extern "C" fn(
        PortCookie: PVOID,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        ReturnOutputBufferLength: PULONG,
    ) -> NTSTATUS,
>;
pub type PFLT_CONNECT_NOTIFY = ::core::option::Option<
    unsafe extern "C" fn(
        ClientPort: PFLT_PORT,
        ServerPortCookie: PVOID,
        ConnectionContext: PVOID,
        SizeOfContext: ULONG,
        ConnectionPortCookie: *mut PVOID,
    ) -> NTSTATUS,
>;
pub type PFLT_DISCONNECT_NOTIFY = ::core::option::Option<
    unsafe extern "C" fn(ConnectionCookie: PVOID),
>;
extern "C" {
    #[must_use]
    pub fn FltCreateCommunicationPort(
        Filter: PFLT_FILTER,
        ServerPort: *mut PFLT_PORT,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ServerPortCookie: PVOID,
        ConnectNotifyCallback: PFLT_CONNECT_NOTIFY,
        DisconnectNotifyCallback: PFLT_DISCONNECT_NOTIFY,
        MessageNotifyCallback: PFLT_MESSAGE_NOTIFY,
        MaxConnections: LONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltCloseCommunicationPort(ServerPort: PFLT_PORT);
}
extern "C" {
    pub fn FltCloseClientPort(Filter: PFLT_FILTER, ClientPort: *mut PFLT_PORT);
}
extern "C" {
    #[must_use]
    pub fn FltSendMessage(
        Filter: PFLT_FILTER,
        ClientPort: *mut PFLT_PORT,
        SenderBuffer: PVOID,
        SenderBufferLength: ULONG,
        ReplyBuffer: PVOID,
        ReplyLength: PULONG,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltBuildDefaultSecurityDescriptor(
        SecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
        DesiredAccess: ACCESS_MASK,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltFreeSecurityDescriptor(SecurityDescriptor: PSECURITY_DESCRIPTOR);
}
pub type PFLT_COMPLETE_CANCELED_CALLBACK = ::core::option::Option<
    unsafe extern "C" fn(CallbackData: PFLT_CALLBACK_DATA),
>;
extern "C" {
    pub fn FltCancelIo(CallbackData: PFLT_CALLBACK_DATA) -> BOOLEAN;
}
extern "C" {
    #[must_use]
    pub fn FltSetCancelCompletion(
        CallbackData: PFLT_CALLBACK_DATA,
        CanceledCallback: PFLT_COMPLETE_CANCELED_CALLBACK,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltClearCancelCompletion(CallbackData: PFLT_CALLBACK_DATA) -> NTSTATUS;
}
extern "C" {
    pub fn FltIsIoCanceled(CallbackData: PFLT_CALLBACK_DATA) -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_DEFERRED_IO_WORKITEM {
    _unused: [u8; 0],
}
pub type PFLT_DEFERRED_IO_WORKITEM = *mut _FLT_DEFERRED_IO_WORKITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_GENERIC_WORKITEM {
    _unused: [u8; 0],
}
pub type PFLT_GENERIC_WORKITEM = *mut _FLT_GENERIC_WORKITEM;
pub type PFLT_DEFERRED_IO_WORKITEM_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        FltWorkItem: PFLT_DEFERRED_IO_WORKITEM,
        CallbackData: PFLT_CALLBACK_DATA,
        Context: PVOID,
    ),
>;
pub type PFLT_GENERIC_WORKITEM_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(
        FltWorkItem: PFLT_GENERIC_WORKITEM,
        FltObject: PVOID,
        Context: PVOID,
    ),
>;
extern "C" {
    pub fn FltAllocateDeferredIoWorkItem() -> PFLT_DEFERRED_IO_WORKITEM;
}
extern "C" {
    pub fn FltFreeDeferredIoWorkItem(FltWorkItem: PFLT_DEFERRED_IO_WORKITEM);
}
extern "C" {
    pub fn FltAllocateGenericWorkItem() -> PFLT_GENERIC_WORKITEM;
}
extern "C" {
    pub fn FltFreeGenericWorkItem(FltWorkItem: PFLT_GENERIC_WORKITEM);
}
extern "C" {
    #[must_use]
    pub fn FltQueueDeferredIoWorkItem(
        FltWorkItem: PFLT_DEFERRED_IO_WORKITEM,
        Data: PFLT_CALLBACK_DATA,
        WorkerRoutine: PFLT_DEFERRED_IO_WORKITEM_ROUTINE,
        QueueType: WORK_QUEUE_TYPE,
        Context: PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltQueueGenericWorkItem(
        FltWorkItem: PFLT_GENERIC_WORKITEM,
        FltObject: PVOID,
        WorkerRoutine: PFLT_GENERIC_WORKITEM_ROUTINE,
        QueueType: WORK_QUEUE_TYPE,
        Context: PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltLockUserBuffer(CallbackData: PFLT_CALLBACK_DATA) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltDecodeParameters(
        CallbackData: PFLT_CALLBACK_DATA,
        MdlAddressPointer: *mut *mut PMDL,
        Buffer: *mut *mut PVOID,
        Length: *mut PULONG,
        DesiredAccess: *mut LOCK_OPERATION,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltGetSwappedBufferMdlAddress(CallbackData: PFLT_CALLBACK_DATA) -> PMDL;
}
extern "C" {
    pub fn FltRetainSwappedBufferMdlAddress(CallbackData: PFLT_CALLBACK_DATA);
}
extern "C" {
    pub fn FltGetNewSystemBufferAddress(CallbackData: PFLT_CALLBACK_DATA) -> PVOID;
}
pub type FLT_CALLBACK_DATA_QUEUE_IO_CONTEXT = IO_CSQ_IRP_CONTEXT;
pub type PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT = *mut IO_CSQ_IRP_CONTEXT;
pub type FLT_CALLBACK_DATA_QUEUE = _FLT_CALLBACK_DATA_QUEUE;
pub type PFLT_CALLBACK_DATA_QUEUE = *mut _FLT_CALLBACK_DATA_QUEUE;
pub type PFLT_CALLBACK_DATA_QUEUE_INSERT_IO = ::core::option::Option<
    unsafe extern "C" fn(
        Cbdq: PFLT_CALLBACK_DATA_QUEUE,
        Cbd: PFLT_CALLBACK_DATA,
        InsertContext: PVOID,
    ) -> NTSTATUS,
>;
pub type PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO = ::core::option::Option<
    unsafe extern "C" fn(Cbdq: PFLT_CALLBACK_DATA_QUEUE, Cbd: PFLT_CALLBACK_DATA),
>;
pub type PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO = ::core::option::Option<
    unsafe extern "C" fn(
        Cbdq: PFLT_CALLBACK_DATA_QUEUE,
        Cbd: PFLT_CALLBACK_DATA,
        PeekContext: PVOID,
    ) -> PFLT_CALLBACK_DATA,
>;
pub type PFLT_CALLBACK_DATA_QUEUE_ACQUIRE = ::core::option::Option<
    unsafe extern "C" fn(Cbdq: PFLT_CALLBACK_DATA_QUEUE, Irql: PKIRQL),
>;
pub type PFLT_CALLBACK_DATA_QUEUE_RELEASE = ::core::option::Option<
    unsafe extern "C" fn(Cbdq: PFLT_CALLBACK_DATA_QUEUE, Irql: KIRQL),
>;
pub type PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO = ::core::option::Option<
    unsafe extern "C" fn(Cbdq: PFLT_CALLBACK_DATA_QUEUE, Cbd: PFLT_CALLBACK_DATA),
>;
pub mod _FLT_CALLBACK_DATA_QUEUE_FLAGS {
    pub type Type = ::core::ffi::c_int;
}
pub use self::_FLT_CALLBACK_DATA_QUEUE_FLAGS::Type as FLT_CALLBACK_DATA_QUEUE_FLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLT_CALLBACK_DATA_QUEUE {
    pub Csq: IO_CSQ,
    pub Flags: FLT_CALLBACK_DATA_QUEUE_FLAGS,
    pub Instance: PFLT_INSTANCE,
    pub InsertIo: PFLT_CALLBACK_DATA_QUEUE_INSERT_IO,
    pub RemoveIo: PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO,
    pub PeekNextIo: PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO,
    pub Acquire: PFLT_CALLBACK_DATA_QUEUE_ACQUIRE,
    pub Release: PFLT_CALLBACK_DATA_QUEUE_RELEASE,
    pub CompleteCanceledIo: PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO,
}
#[test]
fn bindgen_test_layout__FLT_CALLBACK_DATA_QUEUE() {
    const UNINIT: ::core::mem::MaybeUninit<_FLT_CALLBACK_DATA_QUEUE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLT_CALLBACK_DATA_QUEUE>(),
        128usize,
        concat!("Size of: ", stringify!(_FLT_CALLBACK_DATA_QUEUE)),
    );
    assert_eq!(
        ::core::mem::align_of::<_FLT_CALLBACK_DATA_QUEUE>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLT_CALLBACK_DATA_QUEUE)),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Csq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA_QUEUE),
            "::",
            stringify!(Csq),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA_QUEUE),
            "::",
            stringify!(Flags),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Instance) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA_QUEUE),
            "::",
            stringify!(Instance),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InsertIo) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA_QUEUE),
            "::",
            stringify!(InsertIo),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RemoveIo) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA_QUEUE),
            "::",
            stringify!(RemoveIo),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeekNextIo) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA_QUEUE),
            "::",
            stringify!(PeekNextIo),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Acquire) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA_QUEUE),
            "::",
            stringify!(Acquire),
        ),
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Release) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA_QUEUE),
            "::",
            stringify!(Release),
        ),
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CompleteCanceledIo) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLT_CALLBACK_DATA_QUEUE),
            "::",
            stringify!(CompleteCanceledIo),
        ),
    );
}
impl Default for _FLT_CALLBACK_DATA_QUEUE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    pub fn FltCbdqInitialize(
        Instance: PFLT_INSTANCE,
        Cbdq: PFLT_CALLBACK_DATA_QUEUE,
        CbdqInsertIo: PFLT_CALLBACK_DATA_QUEUE_INSERT_IO,
        CbdqRemoveIo: PFLT_CALLBACK_DATA_QUEUE_REMOVE_IO,
        CbdqPeekNextIo: PFLT_CALLBACK_DATA_QUEUE_PEEK_NEXT_IO,
        CbdqAcquire: PFLT_CALLBACK_DATA_QUEUE_ACQUIRE,
        CbdqRelease: PFLT_CALLBACK_DATA_QUEUE_RELEASE,
        CbdqCompleteCanceledIo: PFLT_CALLBACK_DATA_QUEUE_COMPLETE_CANCELED_IO,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltCbdqEnable(Cbdq: PFLT_CALLBACK_DATA_QUEUE);
}
extern "C" {
    pub fn FltCbdqDisable(Cbdq: PFLT_CALLBACK_DATA_QUEUE);
}
extern "C" {
    #[must_use]
    pub fn FltCbdqInsertIo(
        Cbdq: PFLT_CALLBACK_DATA_QUEUE,
        Cbd: PFLT_CALLBACK_DATA,
        Context: PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT,
        InsertContext: PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltCbdqRemoveIo(
        Cbdq: PFLT_CALLBACK_DATA_QUEUE,
        Context: PFLT_CALLBACK_DATA_QUEUE_IO_CONTEXT,
    ) -> PFLT_CALLBACK_DATA;
}
extern "C" {
    pub fn FltCbdqRemoveNextIo(
        Cbdq: PFLT_CALLBACK_DATA_QUEUE,
        PeekContext: PVOID,
    ) -> PFLT_CALLBACK_DATA;
}
pub type PFLTOPLOCK_WAIT_COMPLETE_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(CallbackData: PFLT_CALLBACK_DATA, Context: PVOID),
>;
pub type PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(CallbackData: PFLT_CALLBACK_DATA, Context: PVOID),
>;
extern "C" {
    pub fn FltInitializeOplock(Oplock: POPLOCK);
}
extern "C" {
    pub fn FltUninitializeOplock(Oplock: POPLOCK);
}
extern "C" {
    pub fn FltOplockFsctrl(
        Oplock: POPLOCK,
        CallbackData: PFLT_CALLBACK_DATA,
        OpenCount: ULONG,
    ) -> FLT_PREOP_CALLBACK_STATUS;
}
extern "C" {
    pub fn FltCheckOplock(
        Oplock: POPLOCK,
        CallbackData: PFLT_CALLBACK_DATA,
        Context: PVOID,
        WaitCompletionRoutine: PFLTOPLOCK_WAIT_COMPLETE_ROUTINE,
        PrePostCallbackDataRoutine: PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE,
    ) -> FLT_PREOP_CALLBACK_STATUS;
}
extern "C" {
    pub fn FltOplockIsFastIoPossible(Oplock: POPLOCK) -> BOOLEAN;
}
extern "C" {
    pub fn FltCurrentBatchOplock(Oplock: POPLOCK) -> BOOLEAN;
}
extern "C" {
    pub fn FltCheckOplockEx(
        Oplock: POPLOCK,
        CallbackData: PFLT_CALLBACK_DATA,
        Flags: ULONG,
        Context: PVOID,
        WaitCompletionRoutine: PFLTOPLOCK_WAIT_COMPLETE_ROUTINE,
        PrePostCallbackDataRoutine: PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE,
    ) -> FLT_PREOP_CALLBACK_STATUS;
}
extern "C" {
    pub fn FltCurrentOplock(Oplock: POPLOCK) -> BOOLEAN;
}
extern "C" {
    pub fn FltCurrentOplockH(Oplock: POPLOCK) -> BOOLEAN;
}
extern "C" {
    pub fn FltOplockBreakH(
        Oplock: POPLOCK,
        CallbackData: PFLT_CALLBACK_DATA,
        Flags: ULONG,
        Context: PVOID,
        WaitCompletionRoutine: PFLTOPLOCK_WAIT_COMPLETE_ROUTINE,
        PrePostCallbackDataRoutine: PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE,
    ) -> FLT_PREOP_CALLBACK_STATUS;
}
extern "C" {
    pub fn FltOplockBreakToNone(
        Oplock: POPLOCK,
        CallbackData: PFLT_CALLBACK_DATA,
        Context: PVOID,
        WaitCompletionRoutine: PFLTOPLOCK_WAIT_COMPLETE_ROUTINE,
        PrePostCallbackDataRoutine: PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE,
    ) -> FLT_PREOP_CALLBACK_STATUS;
}
extern "C" {
    pub fn FltOplockBreakToNoneEx(
        Oplock: POPLOCK,
        CallbackData: PFLT_CALLBACK_DATA,
        Flags: ULONG,
        Context: PVOID,
        WaitCompletionRoutine: PFLTOPLOCK_WAIT_COMPLETE_ROUTINE,
        PrePostCallbackDataRoutine: PFLTOPLOCK_PREPOST_CALLBACKDATA_ROUTINE,
    ) -> FLT_PREOP_CALLBACK_STATUS;
}
extern "C" {
    pub fn FltOplockIsSharedRequest(CallbackData: PFLT_CALLBACK_DATA) -> BOOLEAN;
}
extern "C" {
    pub fn FltOplockFsctrlEx(
        Oplock: POPLOCK,
        CallbackData: PFLT_CALLBACK_DATA,
        OpenCount: ULONG,
        Flags: ULONG,
    ) -> FLT_PREOP_CALLBACK_STATUS;
}
extern "C" {
    pub fn FltOplockKeysEqual(Fo1: PFILE_OBJECT, Fo2: PFILE_OBJECT) -> BOOLEAN;
}
pub type PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE = ::core::option::Option<
    unsafe extern "C" fn(Context: PVOID, CallbackData: PFLT_CALLBACK_DATA) -> NTSTATUS,
>;
extern "C" {
    pub fn FltInitializeFileLock(FileLock: PFILE_LOCK);
}
extern "C" {
    pub fn FltUninitializeFileLock(FileLock: PFILE_LOCK);
}
extern "C" {
    pub fn FltAllocateFileLock(
        CompleteLockCallbackDataRoutine: PFLT_COMPLETE_LOCK_CALLBACK_DATA_ROUTINE,
        UnlockRoutine: PUNLOCK_ROUTINE,
    ) -> PFILE_LOCK;
}
extern "C" {
    pub fn FltFreeFileLock(FileLock: PFILE_LOCK);
}
extern "C" {
    pub fn FltProcessFileLock(
        FileLock: PFILE_LOCK,
        CallbackData: PFLT_CALLBACK_DATA,
        Context: PVOID,
    ) -> FLT_PREOP_CALLBACK_STATUS;
}
extern "C" {
    pub fn FltCheckLockForReadAccess(
        FileLock: PFILE_LOCK,
        CallbackData: PFLT_CALLBACK_DATA,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FltCheckLockForWriteAccess(
        FileLock: PFILE_LOCK,
        CallbackData: PFLT_CALLBACK_DATA,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FltAcquireResourceExclusive(Resource: PERESOURCE);
}
extern "C" {
    pub fn FltAcquireResourceShared(Resource: PERESOURCE);
}
extern "C" {
    pub fn FltReleaseResource(Resource: PERESOURCE);
}
extern "C" {
    pub fn FltInitializePushLock(PushLock: PULONG_PTR);
}
extern "C" {
    pub fn FltDeletePushLock(PushLock: PULONG_PTR);
}
extern "C" {
    pub fn FltAcquirePushLockExclusive(PushLock: PULONG_PTR);
}
extern "C" {
    pub fn FltAcquirePushLockShared(PushLock: PULONG_PTR);
}
extern "C" {
    pub fn FltReleasePushLock(PushLock: PULONG_PTR);
}
extern "C" {
    pub fn FltAcquirePushLockExclusiveEx(PushLock: PULONG_PTR, Flags: ULONG);
}
extern "C" {
    pub fn FltAcquirePushLockSharedEx(PushLock: PULONG_PTR, Flags: ULONG);
}
extern "C" {
    pub fn FltReleasePushLockEx(PushLock: PULONG_PTR, Flags: ULONG);
}
extern "C" {
    #[must_use]
    pub fn FltCancellableWaitForSingleObject(
        Object: PVOID,
        Timeout: PLARGE_INTEGER,
        CallbackData: PFLT_CALLBACK_DATA,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltCancellableWaitForMultipleObjects(
        Count: ULONG,
        ObjectArray: *mut PVOID,
        WaitType: WAIT_TYPE,
        Timeout: PLARGE_INTEGER,
        WaitBlockArray: PKWAIT_BLOCK,
        CallbackData: PFLT_CALLBACK_DATA,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltIsOperationSynchronous(CallbackData: PFLT_CALLBACK_DATA) -> BOOLEAN;
}
extern "C" {
    pub fn FltIs32bitProcess(CallbackData: PFLT_CALLBACK_DATA) -> BOOLEAN;
}
extern "C" {
    pub fn FltGetRequestorProcess(CallbackData: PFLT_CALLBACK_DATA) -> PEPROCESS;
}
extern "C" {
    pub fn FltGetRequestorProcessId(CallbackData: PFLT_CALLBACK_DATA) -> ULONG;
}
extern "C" {
    pub fn FltGetRequestorProcessIdEx(CallbackData: PFLT_CALLBACK_DATA) -> HANDLE;
}
extern "C" {
    pub fn FltNotifyFilterChangeDirectory(
        NotifySync: PNOTIFY_SYNC,
        NotifyList: PLIST_ENTRY,
        FsContext: PVOID,
        FullDirectoryName: PSTRING,
        WatchTree: BOOLEAN,
        IgnoreBuffer: BOOLEAN,
        CompletionFilter: ULONG,
        NotifyCallbackData: PFLT_CALLBACK_DATA,
        TraverseCallback: PCHECK_FOR_TRAVERSE_ACCESS,
        SubjectContext: PSECURITY_SUBJECT_CONTEXT,
        FilterCallback: PFILTER_REPORT_CHANGE,
    );
}
extern "C" {
    #[must_use]
    pub fn FltGetRequestorSessionId(
        CallbackData: PFLT_CALLBACK_DATA,
        SessionId: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltAdjustDeviceStackSizeForIoRedirection(
        SourceInstance: PFLT_INSTANCE,
        TargetInstance: PFLT_INSTANCE,
        SourceDeviceStackSizeModified: PBOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltIsIoRedirectionAllowed(
        SourceInstance: PFLT_INSTANCE,
        TargetInstance: PFLT_INSTANCE,
        RedirectionAllowed: PBOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltIsIoRedirectionAllowedForOperation(
        Data: PFLT_CALLBACK_DATA,
        TargetInstance: PFLT_INSTANCE,
        RedirectionAllowedThisIo: PBOOLEAN,
        RedirectionAllowedAllIo: PBOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltVetoBypassIo(
        CallbackData: PFLT_CALLBACK_DATA,
        FltObjects: PCFLT_RELATED_OBJECTS,
        OperationStatus: NTSTATUS,
        FailureReason: PCUNICODE_STRING,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltEnlistInTransaction(
        Instance: PFLT_INSTANCE,
        Transaction: PKTRANSACTION,
        TransactionContext: PFLT_CONTEXT,
        NotificationMask: NOTIFICATION_MASK,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltRollbackEnlistment(
        Instance: PFLT_INSTANCE,
        Transaction: PKTRANSACTION,
        TransactionContext: PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltPrePrepareComplete(
        Instance: PFLT_INSTANCE,
        Transaction: PKTRANSACTION,
        TransactionContext: PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltPrepareComplete(
        Instance: PFLT_INSTANCE,
        Transaction: PKTRANSACTION,
        TransactionContext: PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltCommitComplete(
        Instance: PFLT_INSTANCE,
        Transaction: PKTRANSACTION,
        TransactionContext: PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltCommitFinalizeComplete(
        Instance: PFLT_INSTANCE,
        Transaction: PKTRANSACTION,
        TransactionContext: PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltRollbackComplete(
        Instance: PFLT_INSTANCE,
        Transaction: PKTRANSACTION,
        TransactionContext: PFLT_CONTEXT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltAllocateExtraCreateParameterList(
        Filter: PFLT_FILTER,
        Flags: FSRTL_ALLOCATE_ECPLIST_FLAGS,
        EcpList: *mut PECP_LIST,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltAllocateExtraCreateParameter(
        Filter: PFLT_FILTER,
        EcpType: LPCGUID,
        SizeOfContext: ULONG,
        Flags: FSRTL_ALLOCATE_ECP_FLAGS,
        CleanupCallback: PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK,
        PoolTag: ULONG,
        EcpContext: *mut PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltInitExtraCreateParameterLookasideList(
        Filter: PFLT_FILTER,
        Lookaside: PVOID,
        Flags: FSRTL_ECP_LOOKASIDE_FLAGS,
        Size: SIZE_T,
        Tag: ULONG,
    );
}
extern "C" {
    pub fn FltDeleteExtraCreateParameterLookasideList(
        Filter: PFLT_FILTER,
        Lookaside: PVOID,
        Flags: FSRTL_ECP_LOOKASIDE_FLAGS,
    );
}
extern "C" {
    #[must_use]
    pub fn FltAllocateExtraCreateParameterFromLookasideList(
        Filter: PFLT_FILTER,
        EcpType: LPCGUID,
        SizeOfContext: ULONG,
        Flags: FSRTL_ALLOCATE_ECP_FLAGS,
        CleanupCallback: PFSRTL_EXTRA_CREATE_PARAMETER_CLEANUP_CALLBACK,
        LookasideList: PVOID,
        EcpContext: *mut PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltInsertExtraCreateParameter(
        Filter: PFLT_FILTER,
        EcpList: PECP_LIST,
        EcpContext: PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltFindExtraCreateParameter(
        Filter: PFLT_FILTER,
        EcpList: PECP_LIST,
        EcpType: LPCGUID,
        EcpContext: *mut PVOID,
        EcpContextSize: *mut ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltRemoveExtraCreateParameter(
        Filter: PFLT_FILTER,
        EcpList: PECP_LIST,
        EcpType: LPCGUID,
        EcpContext: *mut PVOID,
        EcpContextSize: *mut ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltFreeExtraCreateParameterList(Filter: PFLT_FILTER, EcpList: PECP_LIST);
}
extern "C" {
    pub fn FltFreeExtraCreateParameter(Filter: PFLT_FILTER, EcpContext: PVOID);
}
extern "C" {
    #[must_use]
    pub fn FltGetEcpListFromCallbackData(
        Filter: PFLT_FILTER,
        CallbackData: PFLT_CALLBACK_DATA,
        EcpList: *mut PECP_LIST,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetEcpListIntoCallbackData(
        Filter: PFLT_FILTER,
        CallbackData: PFLT_CALLBACK_DATA,
        EcpList: PECP_LIST,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetNextExtraCreateParameter(
        Filter: PFLT_FILTER,
        EcpList: PECP_LIST,
        CurrentEcpContext: PVOID,
        NextEcpType: LPGUID,
        NextEcpContext: *mut PVOID,
        NextEcpContextSize: *mut ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltAcknowledgeEcp(Filter: PFLT_FILTER, EcpContext: PVOID);
}
extern "C" {
    pub fn FltIsEcpAcknowledged(Filter: PFLT_FILTER, EcpContext: PVOID) -> BOOLEAN;
}
extern "C" {
    pub fn FltIsEcpFromUserMode(Filter: PFLT_FILTER, EcpContext: PVOID) -> BOOLEAN;
}
extern "C" {
    pub fn FltPrepareToReuseEcp(Filter: PFLT_FILTER, EcpContext: PVOID);
}
extern "C" {
    #[must_use]
    pub fn FltAddOpenReparseEntry(
        Filter: PFLT_FILTER,
        Data: PFLT_CALLBACK_DATA,
        OpenReparseEntry: POPEN_REPARSE_LIST_ENTRY,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltRemoveOpenReparseEntry(
        Filter: PFLT_FILTER,
        Data: PFLT_CALLBACK_DATA,
        OpenReparseEntry: POPEN_REPARSE_LIST_ENTRY,
    );
}
extern "C" {
    #[must_use]
    pub fn FltCopyOpenReparseList(
        Filter: PFLT_FILTER,
        Data: PFLT_CALLBACK_DATA,
        EcpList: PECP_LIST,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltFreeOpenReparseList(Filter: PFLT_FILTER, EcpList: PECP_LIST);
}
extern "C" {
    #[must_use]
    pub fn FltRequestFileInfoOnCreateCompletion(
        Filter: PFLT_FILTER,
        Data: PFLT_CALLBACK_DATA,
        InfoClassFlags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltRetrieveFileInfoOnCreateCompletion(
        Filter: PFLT_FILTER,
        Data: PFLT_CALLBACK_DATA,
        InfoClass: ULONG,
        Size: PULONG,
    ) -> PVOID;
}
extern "C" {
    #[must_use]
    pub fn FltRetrieveFileInfoOnCreateCompletionEx(
        Filter: PFLT_FILTER,
        Data: PFLT_CALLBACK_DATA,
        InfoClass: ULONG,
        RetInfoSize: PULONG,
        RetInfoBuffer: *mut PVOID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltRetrieveIoPriorityInfo(
        Data: PFLT_CALLBACK_DATA,
        FileObject: PFILE_OBJECT,
        Thread: PETHREAD,
        PriorityInfo: PIO_PRIORITY_INFO,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltApplyPriorityInfoThread(
        InputPriorityInfo: PIO_PRIORITY_INFO,
        OutputPriorityInfo: PIO_PRIORITY_INFO,
        Thread: PETHREAD,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltGetIoPriorityHint(Data: PFLT_CALLBACK_DATA) -> IO_PRIORITY_HINT;
}
extern "C" {
    pub fn FltGetIoPriorityHintFromCallbackData(
        Data: PFLT_CALLBACK_DATA,
    ) -> IO_PRIORITY_HINT;
}
extern "C" {
    #[must_use]
    pub fn FltSetIoPriorityHintIntoCallbackData(
        Data: PFLT_CALLBACK_DATA,
        PriorityHint: IO_PRIORITY_HINT,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltGetIoPriorityHintFromFileObject(
        FileObject: PFILE_OBJECT,
    ) -> IO_PRIORITY_HINT;
}
extern "C" {
    #[must_use]
    pub fn FltSetIoPriorityHintIntoFileObject(
        FileObject: PFILE_OBJECT,
        PriorityHint: IO_PRIORITY_HINT,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltGetIoPriorityHintFromThread(Thread: PETHREAD) -> IO_PRIORITY_HINT;
}
extern "C" {
    #[must_use]
    pub fn FltSetIoPriorityHintIntoThread(
        Thread: PETHREAD,
        PriorityHint: IO_PRIORITY_HINT,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetActivityIdCallbackData(
        CallbackData: PFLT_CALLBACK_DATA,
        Guid: LPGUID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetActivityIdCallbackData(
        CallbackData: PFLT_CALLBACK_DATA,
        Guid: LPCGUID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltPropagateActivityIdToThread(
        CallbackData: PFLT_CALLBACK_DATA,
        PropagateId: LPGUID,
        OriginalId: *mut LPCGUID,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetFsZeroingOffset(
        Data: PFLT_CALLBACK_DATA,
        ZeroingOffset: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetFsZeroingOffsetRequired(Data: PFLT_CALLBACK_DATA) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltSetFsZeroingOffset(
        Data: PFLT_CALLBACK_DATA,
        ZeroingOffset: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltGetIoAttributionHandleFromCallbackData(Data: PFLT_CALLBACK_DATA) -> PVOID;
}
extern "C" {
    #[must_use]
    pub fn FltPropagateIrpExtension(
        SourceData: PFLT_CALLBACK_DATA,
        TargetData: PFLT_CALLBACK_DATA,
        Flags: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[must_use]
    pub fn FltGetCopyInformationFromCallbackData(
        Data: PFLT_CALLBACK_DATA,
        CopyInformation: PCOPY_INFORMATION,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FltGetIrpName(IrpMajorCode: UCHAR) -> PCHAR;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _EPROCESS {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IORING_OBJECT {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ECP_LIST {
    pub _address: u8,
}
